// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ActionAcceptNewTaskMyNameActionTaskNewPost invokes action_accept_new_task_my__name__action_task_new_post operation.
	//
	// Accepting a new task.
	//
	// POST /my/{name}/action/task/new
	ActionAcceptNewTaskMyNameActionTaskNewPost(ctx context.Context, params ActionAcceptNewTaskMyNameActionTaskNewPostParams) (ActionAcceptNewTaskMyNameActionTaskNewPostRes, error)
	// ActionBuyBankExpansionMyNameActionBankBuyExpansionPost invokes action_buy_bank_expansion_my__name__action_bank_buy_expansion_post operation.
	//
	// Buy a 20 slots bank expansion.
	//
	// POST /my/{name}/action/bank/buy_expansion
	ActionBuyBankExpansionMyNameActionBankBuyExpansionPost(ctx context.Context, params ActionBuyBankExpansionMyNameActionBankBuyExpansionPostParams) (ActionBuyBankExpansionMyNameActionBankBuyExpansionPostRes, error)
	// ActionChristmasExchangeMyNameActionChristmasExchangePost invokes action_christmas_exchange_my__name__action_christmas_exchange_post operation.
	//
	// Exchange 1 gift for a random reward.
	//
	// POST /my/{name}/action/christmas/exchange
	ActionChristmasExchangeMyNameActionChristmasExchangePost(ctx context.Context, params ActionChristmasExchangeMyNameActionChristmasExchangePostParams) (ActionChristmasExchangeMyNameActionChristmasExchangePostRes, error)
	// ActionCompleteTaskMyNameActionTaskCompletePost invokes action_complete_task_my__name__action_task_complete_post operation.
	//
	// Complete a task.
	//
	// POST /my/{name}/action/task/complete
	ActionCompleteTaskMyNameActionTaskCompletePost(ctx context.Context, params ActionCompleteTaskMyNameActionTaskCompletePostParams) (ActionCompleteTaskMyNameActionTaskCompletePostRes, error)
	// ActionCraftingMyNameActionCraftingPost invokes action_crafting_my__name__action_crafting_post operation.
	//
	// Crafting an item. The character must be on a map with a workshop.
	//
	// POST /my/{name}/action/crafting
	ActionCraftingMyNameActionCraftingPost(ctx context.Context, request *CraftingSchema, params ActionCraftingMyNameActionCraftingPostParams) (ActionCraftingMyNameActionCraftingPostRes, error)
	// ActionDeleteItemMyNameActionDeletePost invokes action_delete_item_my__name__action_delete_post operation.
	//
	// Delete an item from your character's inventory.
	//
	// POST /my/{name}/action/delete
	ActionDeleteItemMyNameActionDeletePost(ctx context.Context, request *SimpleItemSchema, params ActionDeleteItemMyNameActionDeletePostParams) (ActionDeleteItemMyNameActionDeletePostRes, error)
	// ActionDepositBankGoldMyNameActionBankDepositGoldPost invokes action_deposit_bank_gold_my__name__action_bank_deposit_gold_post operation.
	//
	// Deposit gold in a bank on the character's map.
	//
	// POST /my/{name}/action/bank/deposit/gold
	ActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionDepositBankGoldMyNameActionBankDepositGoldPostParams) (ActionDepositBankGoldMyNameActionBankDepositGoldPostRes, error)
	// ActionDepositBankMyNameActionBankDepositPost invokes action_deposit_bank_my__name__action_bank_deposit_post operation.
	//
	// Deposit an item in a bank on the character's map.
	//
	// POST /my/{name}/action/bank/deposit
	ActionDepositBankMyNameActionBankDepositPost(ctx context.Context, request *SimpleItemSchema, params ActionDepositBankMyNameActionBankDepositPostParams) (ActionDepositBankMyNameActionBankDepositPostRes, error)
	// ActionEquipItemMyNameActionEquipPost invokes action_equip_item_my__name__action_equip_post operation.
	//
	// Equip an item on your character.
	//
	// POST /my/{name}/action/equip
	ActionEquipItemMyNameActionEquipPost(ctx context.Context, request *EquipSchema, params ActionEquipItemMyNameActionEquipPostParams) (ActionEquipItemMyNameActionEquipPostRes, error)
	// ActionFightMyNameActionFightPost invokes action_fight_my__name__action_fight_post operation.
	//
	// Start a fight against a monster on the character's map.
	//
	// POST /my/{name}/action/fight
	ActionFightMyNameActionFightPost(ctx context.Context, params ActionFightMyNameActionFightPostParams) (ActionFightMyNameActionFightPostRes, error)
	// ActionGatheringMyNameActionGatheringPost invokes action_gathering_my__name__action_gathering_post operation.
	//
	// Harvest a resource on the character's map.
	//
	// POST /my/{name}/action/gathering
	ActionGatheringMyNameActionGatheringPost(ctx context.Context, params ActionGatheringMyNameActionGatheringPostParams) (ActionGatheringMyNameActionGatheringPostRes, error)
	// ActionGeBuyItemMyNameActionGrandexchangeBuyPost invokes action_ge_buy_item_my__name__action_grandexchange_buy_post operation.
	//
	// Buy an item at the Grand Exchange on the character's map.
	//
	// POST /my/{name}/action/grandexchange/buy
	ActionGeBuyItemMyNameActionGrandexchangeBuyPost(ctx context.Context, request *GEBuyOrderSchema, params ActionGeBuyItemMyNameActionGrandexchangeBuyPostParams) (ActionGeBuyItemMyNameActionGrandexchangeBuyPostRes, error)
	// ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPost invokes action_ge_cancel_sell_order_my__name__action_grandexchange_cancel_post operation.
	//
	// Cancel a sell order at the Grand Exchange on the character's map.
	//
	// POST /my/{name}/action/grandexchange/cancel
	ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPost(ctx context.Context, request *GECancelOrderSchema, params ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostParams) (ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostRes, error)
	// ActionGeCreateSellOrderMyNameActionGrandexchangeSellPost invokes action_ge_create_sell_order_my__name__action_grandexchange_sell_post operation.
	//
	// Create a sell order at the Grand Exchange on the character's map. Please note that a 5% sales tax
	// is charged.
	//
	// POST /my/{name}/action/grandexchange/sell
	ActionGeCreateSellOrderMyNameActionGrandexchangeSellPost(ctx context.Context, request *GEOrderCreationrSchema, params ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostParams) (ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostRes, error)
	// ActionMoveMyNameActionMovePost invokes action_move_my__name__action_move_post operation.
	//
	// Moves a character on the map using the map's X and Y position.
	//
	// POST /my/{name}/action/move
	ActionMoveMyNameActionMovePost(ctx context.Context, request *DestinationSchema, params ActionMoveMyNameActionMovePostParams) (ActionMoveMyNameActionMovePostRes, error)
	// ActionRecyclingMyNameActionRecyclingPost invokes action_recycling_my__name__action_recycling_post operation.
	//
	// Recycling an item. The character must be on a map with a workshop (only for equipments and
	// weapons).
	//
	// POST /my/{name}/action/recycling
	ActionRecyclingMyNameActionRecyclingPost(ctx context.Context, request *RecyclingSchema, params ActionRecyclingMyNameActionRecyclingPostParams) (ActionRecyclingMyNameActionRecyclingPostRes, error)
	// ActionRestMyNameActionRestPost invokes action_rest_my__name__action_rest_post operation.
	//
	// Recovers hit points by resting. (1 second per 5 HP, minimum 3 seconds).
	//
	// POST /my/{name}/action/rest
	ActionRestMyNameActionRestPost(ctx context.Context, params ActionRestMyNameActionRestPostParams) (ActionRestMyNameActionRestPostRes, error)
	// ActionTaskCancelMyNameActionTaskCancelPost invokes action_task_cancel_my__name__action_task_cancel_post operation.
	//
	// Cancel a task for 1 tasks coin.
	//
	// POST /my/{name}/action/task/cancel
	ActionTaskCancelMyNameActionTaskCancelPost(ctx context.Context, params ActionTaskCancelMyNameActionTaskCancelPostParams) (ActionTaskCancelMyNameActionTaskCancelPostRes, error)
	// ActionTaskExchangeMyNameActionTaskExchangePost invokes action_task_exchange_my__name__action_task_exchange_post operation.
	//
	// Exchange 6 tasks coins for a random reward. Rewards are exclusive items or resources.
	//
	// POST /my/{name}/action/task/exchange
	ActionTaskExchangeMyNameActionTaskExchangePost(ctx context.Context, params ActionTaskExchangeMyNameActionTaskExchangePostParams) (ActionTaskExchangeMyNameActionTaskExchangePostRes, error)
	// ActionTaskTradeMyNameActionTaskTradePost invokes action_task_trade_my__name__action_task_trade_post operation.
	//
	// Trading items with a Tasks Master.
	//
	// POST /my/{name}/action/task/trade
	ActionTaskTradeMyNameActionTaskTradePost(ctx context.Context, request *SimpleItemSchema, params ActionTaskTradeMyNameActionTaskTradePostParams) (ActionTaskTradeMyNameActionTaskTradePostRes, error)
	// ActionUnequipItemMyNameActionUnequipPost invokes action_unequip_item_my__name__action_unequip_post operation.
	//
	// Unequip an item on your character.
	//
	// POST /my/{name}/action/unequip
	ActionUnequipItemMyNameActionUnequipPost(ctx context.Context, request *UnequipSchema, params ActionUnequipItemMyNameActionUnequipPostParams) (ActionUnequipItemMyNameActionUnequipPostRes, error)
	// ActionUseItemMyNameActionUsePost invokes action_use_item_my__name__action_use_post operation.
	//
	// Use an item as a consumable.
	//
	// POST /my/{name}/action/use
	ActionUseItemMyNameActionUsePost(ctx context.Context, request *SimpleItemSchema, params ActionUseItemMyNameActionUsePostParams) (ActionUseItemMyNameActionUsePostRes, error)
	// ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost invokes action_withdraw_bank_gold_my__name__action_bank_withdraw_gold_post operation.
	//
	// Withdraw gold from your bank.
	//
	// POST /my/{name}/action/bank/withdraw/gold
	ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostParams) (ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRes, error)
	// ActionWithdrawBankMyNameActionBankWithdrawPost invokes action_withdraw_bank_my__name__action_bank_withdraw_post operation.
	//
	// Take an item from your bank and put it in the character's inventory.
	//
	// POST /my/{name}/action/bank/withdraw
	ActionWithdrawBankMyNameActionBankWithdrawPost(ctx context.Context, request *SimpleItemSchema, params ActionWithdrawBankMyNameActionBankWithdrawPostParams) (ActionWithdrawBankMyNameActionBankWithdrawPostRes, error)
	// ChangePasswordMyChangePasswordPost invokes change_password_my_change_password_post operation.
	//
	// Change your account password. Changing the password reset the account token.
	//
	// POST /my/change_password
	ChangePasswordMyChangePasswordPost(ctx context.Context, request *ChangePassword) (ChangePasswordMyChangePasswordPostRes, error)
	// CreateAccountAccountsCreatePost invokes create_account_accounts_create_post operation.
	//
	// Create Account.
	//
	// POST /accounts/create
	CreateAccountAccountsCreatePost(ctx context.Context, request *AddAccountSchema) (CreateAccountAccountsCreatePostRes, error)
	// CreateCharacterCharactersCreatePost invokes create_character_characters_create_post operation.
	//
	// Create new character on your account. You can create up to 5 characters.
	//
	// POST /characters/create
	CreateCharacterCharactersCreatePost(ctx context.Context, request *AddCharacterSchema) (CreateCharacterCharactersCreatePostRes, error)
	// DeleteCharacterCharactersDeletePost invokes delete_character_characters_delete_post operation.
	//
	// Delete character on your account.
	//
	// POST /characters/delete
	DeleteCharacterCharactersDeletePost(ctx context.Context, request *DeleteCharacterSchema) (DeleteCharacterCharactersDeletePostRes, error)
	// GenerateTokenTokenPost invokes generate_token_token_post operation.
	//
	// Use your account as HTTPBasic Auth to generate your token to use the API. You can also generate
	// your token directly on the website.
	//
	// POST /token
	GenerateTokenTokenPost(ctx context.Context) (GenerateTokenTokenPostRes, error)
	// GetAccountAccountsAccountGet invokes get_account_accounts__account__get operation.
	//
	// Retrieve the details of a character.
	//
	// GET /accounts/{account}
	GetAccountAccountsAccountGet(ctx context.Context, params GetAccountAccountsAccountGetParams) (GetAccountAccountsAccountGetRes, error)
	// GetAccountAchievementsAccountsAccountAchievementsGet invokes get_account_achievements_accounts__account__achievements_get operation.
	//
	// Retrieve the achievements of a account.
	//
	// GET /accounts/{account}/achievements
	GetAccountAchievementsAccountsAccountAchievementsGet(ctx context.Context, params GetAccountAchievementsAccountsAccountAchievementsGetParams) (GetAccountAchievementsAccountsAccountAchievementsGetRes, error)
	// GetAccountDetailsMyDetailsGet invokes get_account_details_my_details_get operation.
	//
	// Fetch account details.
	//
	// GET /my/details
	GetAccountDetailsMyDetailsGet(ctx context.Context) (*MyAccountDetailsSchema, error)
	// GetAccountsLeaderboardLeaderboardAccountsGet invokes get_accounts_leaderboard_leaderboard_accounts_get operation.
	//
	// Fetch leaderboard details.
	//
	// GET /leaderboard/accounts
	GetAccountsLeaderboardLeaderboardAccountsGet(ctx context.Context, params GetAccountsLeaderboardLeaderboardAccountsGetParams) (*DataPageAccountLeaderboardSchema, error)
	// GetAchievementAchievementsCodeGet invokes get_achievement_achievements__code__get operation.
	//
	// Retrieve the details of a achievement.
	//
	// GET /achievements/{code}
	GetAchievementAchievementsCodeGet(ctx context.Context, params GetAchievementAchievementsCodeGetParams) (GetAchievementAchievementsCodeGetRes, error)
	// GetAllAchievementsAchievementsGet invokes get_all_achievements_achievements_get operation.
	//
	// List of all achievements.
	//
	// GET /achievements
	GetAllAchievementsAchievementsGet(ctx context.Context, params GetAllAchievementsAchievementsGetParams) (*DataPageAchievementSchema, error)
	// GetAllActiveEventsEventsActiveGet invokes get_all_active_events_events_active_get operation.
	//
	// Fetch active events details.
	//
	// GET /events/active
	GetAllActiveEventsEventsActiveGet(ctx context.Context, params GetAllActiveEventsEventsActiveGetParams) (*DataPageActiveEventSchema, error)
	// GetAllBadgesBadgesGet invokes get_all_badges_badges_get operation.
	//
	// List of all badges.
	//
	// GET /badges
	GetAllBadgesBadgesGet(ctx context.Context, params GetAllBadgesBadgesGetParams) (*DataPageBadgeSchema, error)
	// GetAllCharactersLogsMyLogsGet invokes get_all_characters_logs_my_logs_get operation.
	//
	// History of the last 100 actions of all your characters.
	//
	// GET /my/logs
	GetAllCharactersLogsMyLogsGet(ctx context.Context, params GetAllCharactersLogsMyLogsGetParams) (GetAllCharactersLogsMyLogsGetRes, error)
	// GetAllEventsEventsGet invokes get_all_events_events_get operation.
	//
	// Fetch events details.
	//
	// GET /events
	GetAllEventsEventsGet(ctx context.Context, params GetAllEventsEventsGetParams) (*DataPageEventSchema, error)
	// GetAllItemsItemsGet invokes get_all_items_items_get operation.
	//
	// Fetch items details.
	//
	// GET /items
	GetAllItemsItemsGet(ctx context.Context, params GetAllItemsItemsGetParams) (*DataPageItemSchema, error)
	// GetAllMapsMapsGet invokes get_all_maps_maps_get operation.
	//
	// Fetch maps details.
	//
	// GET /maps
	GetAllMapsMapsGet(ctx context.Context, params GetAllMapsMapsGetParams) (*DataPageMapSchema, error)
	// GetAllMonstersMonstersGet invokes get_all_monsters_monsters_get operation.
	//
	// Fetch monsters details.
	//
	// GET /monsters
	GetAllMonstersMonstersGet(ctx context.Context, params GetAllMonstersMonstersGetParams) (*DataPageMonsterSchema, error)
	// GetAllResourcesResourcesGet invokes get_all_resources_resources_get operation.
	//
	// Fetch resources details.
	//
	// GET /resources
	GetAllResourcesResourcesGet(ctx context.Context, params GetAllResourcesResourcesGetParams) (*DataPageResourceSchema, error)
	// GetAllTasksRewardsTasksRewardsGet invokes get_all_tasks_rewards_tasks_rewards_get operation.
	//
	// Fetch the list of all tasks rewards. To obtain these rewards, you must exchange 6 task coins with
	// a tasks master.
	//
	// GET /tasks/rewards
	GetAllTasksRewardsTasksRewardsGet(ctx context.Context, params GetAllTasksRewardsTasksRewardsGetParams) (*DataPageDropRateSchema, error)
	// GetAllTasksTasksListGet invokes get_all_tasks_tasks_list_get operation.
	//
	// Fetch the list of all tasks.
	//
	// GET /tasks/list
	GetAllTasksTasksListGet(ctx context.Context, params GetAllTasksTasksListGetParams) (*DataPageTaskFullSchema, error)
	// GetBadgeBadgesCodeGet invokes get_badge_badges__code__get operation.
	//
	// Retrieve the details of a badge.
	//
	// GET /badges/{code}
	GetBadgeBadgesCodeGet(ctx context.Context, params GetBadgeBadgesCodeGetParams) (GetBadgeBadgesCodeGetRes, error)
	// GetBankDetailsMyBankGet invokes get_bank_details_my_bank_get operation.
	//
	// Fetch bank details.
	//
	// GET /my/bank
	GetBankDetailsMyBankGet(ctx context.Context) (*BankResponseSchema, error)
	// GetBankItemsMyBankItemsGet invokes get_bank_items_my_bank_items_get operation.
	//
	// Fetch all items in your bank.
	//
	// GET /my/bank/items
	GetBankItemsMyBankItemsGet(ctx context.Context, params GetBankItemsMyBankItemsGetParams) (*DataPageSimpleItemSchema, error)
	// GetCharacterCharactersNameGet invokes get_character_characters__name__get operation.
	//
	// Retrieve the details of a character.
	//
	// GET /characters/{name}
	GetCharacterCharactersNameGet(ctx context.Context, params GetCharacterCharactersNameGetParams) (GetCharacterCharactersNameGetRes, error)
	// GetCharactersLeaderboardLeaderboardCharactersGet invokes get_characters_leaderboard_leaderboard_characters_get operation.
	//
	// Fetch leaderboard details.
	//
	// GET /leaderboard/characters
	GetCharactersLeaderboardLeaderboardCharactersGet(ctx context.Context, params GetCharactersLeaderboardLeaderboardCharactersGetParams) (*DataPageCharacterLeaderboardSchema, error)
	// GetGeSellHistoryGrandexchangeHistoryCodeGet invokes get_ge_sell_history_grandexchange_history__code__get operation.
	//
	// Fetch the sales history of the item for the last 7 days.
	//
	// GET /grandexchange/history/{code}
	GetGeSellHistoryGrandexchangeHistoryCodeGet(ctx context.Context, params GetGeSellHistoryGrandexchangeHistoryCodeGetParams) (GetGeSellHistoryGrandexchangeHistoryCodeGetRes, error)
	// GetGeSellHistoryMyGrandexchangeHistoryGet invokes get_ge_sell_history_my_grandexchange_history_get operation.
	//
	// Fetch your sales history of the last 7 days.
	//
	// GET /my/grandexchange/history
	GetGeSellHistoryMyGrandexchangeHistoryGet(ctx context.Context, params GetGeSellHistoryMyGrandexchangeHistoryGetParams) (*DataPageGeOrderHistorySchema, error)
	// GetGeSellOrderGrandexchangeOrdersIDGet invokes get_ge_sell_order_grandexchange_orders__id__get operation.
	//
	// Retrieve the sell order of a item.
	//
	// GET /grandexchange/orders/{id}
	GetGeSellOrderGrandexchangeOrdersIDGet(ctx context.Context, params GetGeSellOrderGrandexchangeOrdersIDGetParams) (GetGeSellOrderGrandexchangeOrdersIDGetRes, error)
	// GetGeSellOrdersGrandexchangeOrdersGet invokes get_ge_sell_orders_grandexchange_orders_get operation.
	//
	// Fetch all sell orders.
	//
	// GET /grandexchange/orders
	GetGeSellOrdersGrandexchangeOrdersGet(ctx context.Context, params GetGeSellOrdersGrandexchangeOrdersGetParams) (*DataPageGEOrderSchema, error)
	// GetGeSellOrdersMyGrandexchangeOrdersGet invokes get_ge_sell_orders_my_grandexchange_orders_get operation.
	//
	// Fetch your sell orders details.
	//
	// GET /my/grandexchange/orders
	GetGeSellOrdersMyGrandexchangeOrdersGet(ctx context.Context, params GetGeSellOrdersMyGrandexchangeOrdersGetParams) (*DataPageGEOrderSchema, error)
	// GetItemItemsCodeGet invokes get_item_items__code__get operation.
	//
	// Retrieve the details of a item.
	//
	// GET /items/{code}
	GetItemItemsCodeGet(ctx context.Context, params GetItemItemsCodeGetParams) (GetItemItemsCodeGetRes, error)
	// GetMapMapsXYGet invokes get_map_maps__x___y__get operation.
	//
	// Retrieve the details of a map.
	//
	// GET /maps/{x}/{y}
	GetMapMapsXYGet(ctx context.Context, params GetMapMapsXYGetParams) (GetMapMapsXYGetRes, error)
	// GetMonsterMonstersCodeGet invokes get_monster_monsters__code__get operation.
	//
	// Retrieve the details of a monster.
	//
	// GET /monsters/{code}
	GetMonsterMonstersCodeGet(ctx context.Context, params GetMonsterMonstersCodeGetParams) (GetMonsterMonstersCodeGetRes, error)
	// GetMyCharactersMyCharactersGet invokes get_my_characters_my_characters_get operation.
	//
	// List of your characters.
	//
	// GET /my/characters
	GetMyCharactersMyCharactersGet(ctx context.Context) (*MyCharactersListSchema, error)
	// GetResourceResourcesCodeGet invokes get_resource_resources__code__get operation.
	//
	// Retrieve the details of a resource.
	//
	// GET /resources/{code}
	GetResourceResourcesCodeGet(ctx context.Context, params GetResourceResourcesCodeGetParams) (GetResourceResourcesCodeGetRes, error)
	// GetStatusGet invokes get_status__get operation.
	//
	// Return the status of the game server.
	//
	// GET /
	GetStatusGet(ctx context.Context) (*StatusResponseSchema, error)
	// GetTaskTasksListCodeGet invokes get_task_tasks_list__code__get operation.
	//
	// Retrieve the details of a task.
	//
	// GET /tasks/list/{code}
	GetTaskTasksListCodeGet(ctx context.Context, params GetTaskTasksListCodeGetParams) (GetTaskTasksListCodeGetRes, error)
	// GetTasksRewardTasksRewardsCodeGet invokes get_tasks_reward_tasks_rewards__code__get operation.
	//
	// Retrieve the details of a tasks reward.
	//
	// GET /tasks/rewards/{code}
	GetTasksRewardTasksRewardsCodeGet(ctx context.Context, params GetTasksRewardTasksRewardsCodeGetParams) (GetTasksRewardTasksRewardsCodeGetRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// ActionAcceptNewTaskMyNameActionTaskNewPost invokes action_accept_new_task_my__name__action_task_new_post operation.
//
// Accepting a new task.
//
// POST /my/{name}/action/task/new
func (c *Client) ActionAcceptNewTaskMyNameActionTaskNewPost(ctx context.Context, params ActionAcceptNewTaskMyNameActionTaskNewPostParams) (ActionAcceptNewTaskMyNameActionTaskNewPostRes, error) {
	res, err := c.sendActionAcceptNewTaskMyNameActionTaskNewPost(ctx, params)
	return res, err
}

func (c *Client) sendActionAcceptNewTaskMyNameActionTaskNewPost(ctx context.Context, params ActionAcceptNewTaskMyNameActionTaskNewPostParams) (res ActionAcceptNewTaskMyNameActionTaskNewPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_accept_new_task_my__name__action_task_new_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/task/new"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionAcceptNewTaskMyNameActionTaskNewPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/task/new"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionAcceptNewTaskMyNameActionTaskNewPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionAcceptNewTaskMyNameActionTaskNewPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionBuyBankExpansionMyNameActionBankBuyExpansionPost invokes action_buy_bank_expansion_my__name__action_bank_buy_expansion_post operation.
//
// Buy a 20 slots bank expansion.
//
// POST /my/{name}/action/bank/buy_expansion
func (c *Client) ActionBuyBankExpansionMyNameActionBankBuyExpansionPost(ctx context.Context, params ActionBuyBankExpansionMyNameActionBankBuyExpansionPostParams) (ActionBuyBankExpansionMyNameActionBankBuyExpansionPostRes, error) {
	res, err := c.sendActionBuyBankExpansionMyNameActionBankBuyExpansionPost(ctx, params)
	return res, err
}

func (c *Client) sendActionBuyBankExpansionMyNameActionBankBuyExpansionPost(ctx context.Context, params ActionBuyBankExpansionMyNameActionBankBuyExpansionPostParams) (res ActionBuyBankExpansionMyNameActionBankBuyExpansionPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_buy_bank_expansion_my__name__action_bank_buy_expansion_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/buy_expansion"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionBuyBankExpansionMyNameActionBankBuyExpansionPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/buy_expansion"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionBuyBankExpansionMyNameActionBankBuyExpansionPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionBuyBankExpansionMyNameActionBankBuyExpansionPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionChristmasExchangeMyNameActionChristmasExchangePost invokes action_christmas_exchange_my__name__action_christmas_exchange_post operation.
//
// Exchange 1 gift for a random reward.
//
// POST /my/{name}/action/christmas/exchange
func (c *Client) ActionChristmasExchangeMyNameActionChristmasExchangePost(ctx context.Context, params ActionChristmasExchangeMyNameActionChristmasExchangePostParams) (ActionChristmasExchangeMyNameActionChristmasExchangePostRes, error) {
	res, err := c.sendActionChristmasExchangeMyNameActionChristmasExchangePost(ctx, params)
	return res, err
}

func (c *Client) sendActionChristmasExchangeMyNameActionChristmasExchangePost(ctx context.Context, params ActionChristmasExchangeMyNameActionChristmasExchangePostParams) (res ActionChristmasExchangeMyNameActionChristmasExchangePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_christmas_exchange_my__name__action_christmas_exchange_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/christmas/exchange"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionChristmasExchangeMyNameActionChristmasExchangePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/christmas/exchange"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionChristmasExchangeMyNameActionChristmasExchangePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionChristmasExchangeMyNameActionChristmasExchangePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionCompleteTaskMyNameActionTaskCompletePost invokes action_complete_task_my__name__action_task_complete_post operation.
//
// Complete a task.
//
// POST /my/{name}/action/task/complete
func (c *Client) ActionCompleteTaskMyNameActionTaskCompletePost(ctx context.Context, params ActionCompleteTaskMyNameActionTaskCompletePostParams) (ActionCompleteTaskMyNameActionTaskCompletePostRes, error) {
	res, err := c.sendActionCompleteTaskMyNameActionTaskCompletePost(ctx, params)
	return res, err
}

func (c *Client) sendActionCompleteTaskMyNameActionTaskCompletePost(ctx context.Context, params ActionCompleteTaskMyNameActionTaskCompletePostParams) (res ActionCompleteTaskMyNameActionTaskCompletePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_complete_task_my__name__action_task_complete_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/task/complete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionCompleteTaskMyNameActionTaskCompletePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/task/complete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionCompleteTaskMyNameActionTaskCompletePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionCompleteTaskMyNameActionTaskCompletePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionCraftingMyNameActionCraftingPost invokes action_crafting_my__name__action_crafting_post operation.
//
// Crafting an item. The character must be on a map with a workshop.
//
// POST /my/{name}/action/crafting
func (c *Client) ActionCraftingMyNameActionCraftingPost(ctx context.Context, request *CraftingSchema, params ActionCraftingMyNameActionCraftingPostParams) (ActionCraftingMyNameActionCraftingPostRes, error) {
	res, err := c.sendActionCraftingMyNameActionCraftingPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionCraftingMyNameActionCraftingPost(ctx context.Context, request *CraftingSchema, params ActionCraftingMyNameActionCraftingPostParams) (res ActionCraftingMyNameActionCraftingPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_crafting_my__name__action_crafting_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/crafting"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionCraftingMyNameActionCraftingPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/crafting"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionCraftingMyNameActionCraftingPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionCraftingMyNameActionCraftingPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionCraftingMyNameActionCraftingPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionDeleteItemMyNameActionDeletePost invokes action_delete_item_my__name__action_delete_post operation.
//
// Delete an item from your character's inventory.
//
// POST /my/{name}/action/delete
func (c *Client) ActionDeleteItemMyNameActionDeletePost(ctx context.Context, request *SimpleItemSchema, params ActionDeleteItemMyNameActionDeletePostParams) (ActionDeleteItemMyNameActionDeletePostRes, error) {
	res, err := c.sendActionDeleteItemMyNameActionDeletePost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionDeleteItemMyNameActionDeletePost(ctx context.Context, request *SimpleItemSchema, params ActionDeleteItemMyNameActionDeletePostParams) (res ActionDeleteItemMyNameActionDeletePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_delete_item_my__name__action_delete_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/delete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionDeleteItemMyNameActionDeletePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionDeleteItemMyNameActionDeletePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionDeleteItemMyNameActionDeletePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionDeleteItemMyNameActionDeletePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionDepositBankGoldMyNameActionBankDepositGoldPost invokes action_deposit_bank_gold_my__name__action_bank_deposit_gold_post operation.
//
// Deposit gold in a bank on the character's map.
//
// POST /my/{name}/action/bank/deposit/gold
func (c *Client) ActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionDepositBankGoldMyNameActionBankDepositGoldPostParams) (ActionDepositBankGoldMyNameActionBankDepositGoldPostRes, error) {
	res, err := c.sendActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionDepositBankGoldMyNameActionBankDepositGoldPostParams) (res ActionDepositBankGoldMyNameActionBankDepositGoldPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_deposit_bank_gold_my__name__action_bank_deposit_gold_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/deposit/gold"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionDepositBankGoldMyNameActionBankDepositGoldPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/deposit/gold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionDepositBankGoldMyNameActionBankDepositGoldPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionDepositBankGoldMyNameActionBankDepositGoldPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionDepositBankGoldMyNameActionBankDepositGoldPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionDepositBankMyNameActionBankDepositPost invokes action_deposit_bank_my__name__action_bank_deposit_post operation.
//
// Deposit an item in a bank on the character's map.
//
// POST /my/{name}/action/bank/deposit
func (c *Client) ActionDepositBankMyNameActionBankDepositPost(ctx context.Context, request *SimpleItemSchema, params ActionDepositBankMyNameActionBankDepositPostParams) (ActionDepositBankMyNameActionBankDepositPostRes, error) {
	res, err := c.sendActionDepositBankMyNameActionBankDepositPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionDepositBankMyNameActionBankDepositPost(ctx context.Context, request *SimpleItemSchema, params ActionDepositBankMyNameActionBankDepositPostParams) (res ActionDepositBankMyNameActionBankDepositPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_deposit_bank_my__name__action_bank_deposit_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/deposit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionDepositBankMyNameActionBankDepositPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/deposit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionDepositBankMyNameActionBankDepositPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionDepositBankMyNameActionBankDepositPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionDepositBankMyNameActionBankDepositPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionEquipItemMyNameActionEquipPost invokes action_equip_item_my__name__action_equip_post operation.
//
// Equip an item on your character.
//
// POST /my/{name}/action/equip
func (c *Client) ActionEquipItemMyNameActionEquipPost(ctx context.Context, request *EquipSchema, params ActionEquipItemMyNameActionEquipPostParams) (ActionEquipItemMyNameActionEquipPostRes, error) {
	res, err := c.sendActionEquipItemMyNameActionEquipPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionEquipItemMyNameActionEquipPost(ctx context.Context, request *EquipSchema, params ActionEquipItemMyNameActionEquipPostParams) (res ActionEquipItemMyNameActionEquipPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_equip_item_my__name__action_equip_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/equip"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionEquipItemMyNameActionEquipPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/equip"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionEquipItemMyNameActionEquipPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionEquipItemMyNameActionEquipPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionEquipItemMyNameActionEquipPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionFightMyNameActionFightPost invokes action_fight_my__name__action_fight_post operation.
//
// Start a fight against a monster on the character's map.
//
// POST /my/{name}/action/fight
func (c *Client) ActionFightMyNameActionFightPost(ctx context.Context, params ActionFightMyNameActionFightPostParams) (ActionFightMyNameActionFightPostRes, error) {
	res, err := c.sendActionFightMyNameActionFightPost(ctx, params)
	return res, err
}

func (c *Client) sendActionFightMyNameActionFightPost(ctx context.Context, params ActionFightMyNameActionFightPostParams) (res ActionFightMyNameActionFightPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_fight_my__name__action_fight_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/fight"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionFightMyNameActionFightPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/fight"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionFightMyNameActionFightPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionFightMyNameActionFightPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionGatheringMyNameActionGatheringPost invokes action_gathering_my__name__action_gathering_post operation.
//
// Harvest a resource on the character's map.
//
// POST /my/{name}/action/gathering
func (c *Client) ActionGatheringMyNameActionGatheringPost(ctx context.Context, params ActionGatheringMyNameActionGatheringPostParams) (ActionGatheringMyNameActionGatheringPostRes, error) {
	res, err := c.sendActionGatheringMyNameActionGatheringPost(ctx, params)
	return res, err
}

func (c *Client) sendActionGatheringMyNameActionGatheringPost(ctx context.Context, params ActionGatheringMyNameActionGatheringPostParams) (res ActionGatheringMyNameActionGatheringPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_gathering_my__name__action_gathering_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/gathering"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionGatheringMyNameActionGatheringPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/gathering"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionGatheringMyNameActionGatheringPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionGatheringMyNameActionGatheringPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionGeBuyItemMyNameActionGrandexchangeBuyPost invokes action_ge_buy_item_my__name__action_grandexchange_buy_post operation.
//
// Buy an item at the Grand Exchange on the character's map.
//
// POST /my/{name}/action/grandexchange/buy
func (c *Client) ActionGeBuyItemMyNameActionGrandexchangeBuyPost(ctx context.Context, request *GEBuyOrderSchema, params ActionGeBuyItemMyNameActionGrandexchangeBuyPostParams) (ActionGeBuyItemMyNameActionGrandexchangeBuyPostRes, error) {
	res, err := c.sendActionGeBuyItemMyNameActionGrandexchangeBuyPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionGeBuyItemMyNameActionGrandexchangeBuyPost(ctx context.Context, request *GEBuyOrderSchema, params ActionGeBuyItemMyNameActionGrandexchangeBuyPostParams) (res ActionGeBuyItemMyNameActionGrandexchangeBuyPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_ge_buy_item_my__name__action_grandexchange_buy_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/grandexchange/buy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionGeBuyItemMyNameActionGrandexchangeBuyPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/grandexchange/buy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionGeBuyItemMyNameActionGrandexchangeBuyPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionGeBuyItemMyNameActionGrandexchangeBuyPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionGeBuyItemMyNameActionGrandexchangeBuyPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPost invokes action_ge_cancel_sell_order_my__name__action_grandexchange_cancel_post operation.
//
// Cancel a sell order at the Grand Exchange on the character's map.
//
// POST /my/{name}/action/grandexchange/cancel
func (c *Client) ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPost(ctx context.Context, request *GECancelOrderSchema, params ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostParams) (ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostRes, error) {
	res, err := c.sendActionGeCancelSellOrderMyNameActionGrandexchangeCancelPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionGeCancelSellOrderMyNameActionGrandexchangeCancelPost(ctx context.Context, request *GECancelOrderSchema, params ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostParams) (res ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_ge_cancel_sell_order_my__name__action_grandexchange_cancel_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/grandexchange/cancel"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/grandexchange/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionGeCreateSellOrderMyNameActionGrandexchangeSellPost invokes action_ge_create_sell_order_my__name__action_grandexchange_sell_post operation.
//
// Create a sell order at the Grand Exchange on the character's map. Please note that a 5% sales tax
// is charged.
//
// POST /my/{name}/action/grandexchange/sell
func (c *Client) ActionGeCreateSellOrderMyNameActionGrandexchangeSellPost(ctx context.Context, request *GEOrderCreationrSchema, params ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostParams) (ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostRes, error) {
	res, err := c.sendActionGeCreateSellOrderMyNameActionGrandexchangeSellPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionGeCreateSellOrderMyNameActionGrandexchangeSellPost(ctx context.Context, request *GEOrderCreationrSchema, params ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostParams) (res ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_ge_create_sell_order_my__name__action_grandexchange_sell_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/grandexchange/sell"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionGeCreateSellOrderMyNameActionGrandexchangeSellPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/grandexchange/sell"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionGeCreateSellOrderMyNameActionGrandexchangeSellPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionGeCreateSellOrderMyNameActionGrandexchangeSellPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionGeCreateSellOrderMyNameActionGrandexchangeSellPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionMoveMyNameActionMovePost invokes action_move_my__name__action_move_post operation.
//
// Moves a character on the map using the map's X and Y position.
//
// POST /my/{name}/action/move
func (c *Client) ActionMoveMyNameActionMovePost(ctx context.Context, request *DestinationSchema, params ActionMoveMyNameActionMovePostParams) (ActionMoveMyNameActionMovePostRes, error) {
	res, err := c.sendActionMoveMyNameActionMovePost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionMoveMyNameActionMovePost(ctx context.Context, request *DestinationSchema, params ActionMoveMyNameActionMovePostParams) (res ActionMoveMyNameActionMovePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_move_my__name__action_move_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/move"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionMoveMyNameActionMovePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/move"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionMoveMyNameActionMovePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionMoveMyNameActionMovePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionMoveMyNameActionMovePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionRecyclingMyNameActionRecyclingPost invokes action_recycling_my__name__action_recycling_post operation.
//
// Recycling an item. The character must be on a map with a workshop (only for equipments and
// weapons).
//
// POST /my/{name}/action/recycling
func (c *Client) ActionRecyclingMyNameActionRecyclingPost(ctx context.Context, request *RecyclingSchema, params ActionRecyclingMyNameActionRecyclingPostParams) (ActionRecyclingMyNameActionRecyclingPostRes, error) {
	res, err := c.sendActionRecyclingMyNameActionRecyclingPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionRecyclingMyNameActionRecyclingPost(ctx context.Context, request *RecyclingSchema, params ActionRecyclingMyNameActionRecyclingPostParams) (res ActionRecyclingMyNameActionRecyclingPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_recycling_my__name__action_recycling_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/recycling"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionRecyclingMyNameActionRecyclingPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/recycling"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionRecyclingMyNameActionRecyclingPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionRecyclingMyNameActionRecyclingPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionRecyclingMyNameActionRecyclingPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionRestMyNameActionRestPost invokes action_rest_my__name__action_rest_post operation.
//
// Recovers hit points by resting. (1 second per 5 HP, minimum 3 seconds).
//
// POST /my/{name}/action/rest
func (c *Client) ActionRestMyNameActionRestPost(ctx context.Context, params ActionRestMyNameActionRestPostParams) (ActionRestMyNameActionRestPostRes, error) {
	res, err := c.sendActionRestMyNameActionRestPost(ctx, params)
	return res, err
}

func (c *Client) sendActionRestMyNameActionRestPost(ctx context.Context, params ActionRestMyNameActionRestPostParams) (res ActionRestMyNameActionRestPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_rest_my__name__action_rest_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/rest"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionRestMyNameActionRestPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/rest"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionRestMyNameActionRestPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionRestMyNameActionRestPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionTaskCancelMyNameActionTaskCancelPost invokes action_task_cancel_my__name__action_task_cancel_post operation.
//
// Cancel a task for 1 tasks coin.
//
// POST /my/{name}/action/task/cancel
func (c *Client) ActionTaskCancelMyNameActionTaskCancelPost(ctx context.Context, params ActionTaskCancelMyNameActionTaskCancelPostParams) (ActionTaskCancelMyNameActionTaskCancelPostRes, error) {
	res, err := c.sendActionTaskCancelMyNameActionTaskCancelPost(ctx, params)
	return res, err
}

func (c *Client) sendActionTaskCancelMyNameActionTaskCancelPost(ctx context.Context, params ActionTaskCancelMyNameActionTaskCancelPostParams) (res ActionTaskCancelMyNameActionTaskCancelPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_task_cancel_my__name__action_task_cancel_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/task/cancel"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionTaskCancelMyNameActionTaskCancelPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/task/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionTaskCancelMyNameActionTaskCancelPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionTaskCancelMyNameActionTaskCancelPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionTaskExchangeMyNameActionTaskExchangePost invokes action_task_exchange_my__name__action_task_exchange_post operation.
//
// Exchange 6 tasks coins for a random reward. Rewards are exclusive items or resources.
//
// POST /my/{name}/action/task/exchange
func (c *Client) ActionTaskExchangeMyNameActionTaskExchangePost(ctx context.Context, params ActionTaskExchangeMyNameActionTaskExchangePostParams) (ActionTaskExchangeMyNameActionTaskExchangePostRes, error) {
	res, err := c.sendActionTaskExchangeMyNameActionTaskExchangePost(ctx, params)
	return res, err
}

func (c *Client) sendActionTaskExchangeMyNameActionTaskExchangePost(ctx context.Context, params ActionTaskExchangeMyNameActionTaskExchangePostParams) (res ActionTaskExchangeMyNameActionTaskExchangePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_task_exchange_my__name__action_task_exchange_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/task/exchange"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionTaskExchangeMyNameActionTaskExchangePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/task/exchange"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionTaskExchangeMyNameActionTaskExchangePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionTaskExchangeMyNameActionTaskExchangePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionTaskTradeMyNameActionTaskTradePost invokes action_task_trade_my__name__action_task_trade_post operation.
//
// Trading items with a Tasks Master.
//
// POST /my/{name}/action/task/trade
func (c *Client) ActionTaskTradeMyNameActionTaskTradePost(ctx context.Context, request *SimpleItemSchema, params ActionTaskTradeMyNameActionTaskTradePostParams) (ActionTaskTradeMyNameActionTaskTradePostRes, error) {
	res, err := c.sendActionTaskTradeMyNameActionTaskTradePost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionTaskTradeMyNameActionTaskTradePost(ctx context.Context, request *SimpleItemSchema, params ActionTaskTradeMyNameActionTaskTradePostParams) (res ActionTaskTradeMyNameActionTaskTradePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_task_trade_my__name__action_task_trade_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/task/trade"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionTaskTradeMyNameActionTaskTradePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/task/trade"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionTaskTradeMyNameActionTaskTradePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionTaskTradeMyNameActionTaskTradePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionTaskTradeMyNameActionTaskTradePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionUnequipItemMyNameActionUnequipPost invokes action_unequip_item_my__name__action_unequip_post operation.
//
// Unequip an item on your character.
//
// POST /my/{name}/action/unequip
func (c *Client) ActionUnequipItemMyNameActionUnequipPost(ctx context.Context, request *UnequipSchema, params ActionUnequipItemMyNameActionUnequipPostParams) (ActionUnequipItemMyNameActionUnequipPostRes, error) {
	res, err := c.sendActionUnequipItemMyNameActionUnequipPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionUnequipItemMyNameActionUnequipPost(ctx context.Context, request *UnequipSchema, params ActionUnequipItemMyNameActionUnequipPostParams) (res ActionUnequipItemMyNameActionUnequipPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_unequip_item_my__name__action_unequip_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/unequip"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionUnequipItemMyNameActionUnequipPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/unequip"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionUnequipItemMyNameActionUnequipPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionUnequipItemMyNameActionUnequipPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionUnequipItemMyNameActionUnequipPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionUseItemMyNameActionUsePost invokes action_use_item_my__name__action_use_post operation.
//
// Use an item as a consumable.
//
// POST /my/{name}/action/use
func (c *Client) ActionUseItemMyNameActionUsePost(ctx context.Context, request *SimpleItemSchema, params ActionUseItemMyNameActionUsePostParams) (ActionUseItemMyNameActionUsePostRes, error) {
	res, err := c.sendActionUseItemMyNameActionUsePost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionUseItemMyNameActionUsePost(ctx context.Context, request *SimpleItemSchema, params ActionUseItemMyNameActionUsePostParams) (res ActionUseItemMyNameActionUsePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_use_item_my__name__action_use_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/use"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionUseItemMyNameActionUsePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/use"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionUseItemMyNameActionUsePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionUseItemMyNameActionUsePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionUseItemMyNameActionUsePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost invokes action_withdraw_bank_gold_my__name__action_bank_withdraw_gold_post operation.
//
// Withdraw gold from your bank.
//
// POST /my/{name}/action/bank/withdraw/gold
func (c *Client) ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostParams) (ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRes, error) {
	res, err := c.sendActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx context.Context, request *DepositWithdrawGoldSchema, params ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostParams) (res ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_withdraw_bank_gold_my__name__action_bank_withdraw_gold_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/withdraw/gold"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/withdraw/gold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ActionWithdrawBankMyNameActionBankWithdrawPost invokes action_withdraw_bank_my__name__action_bank_withdraw_post operation.
//
// Take an item from your bank and put it in the character's inventory.
//
// POST /my/{name}/action/bank/withdraw
func (c *Client) ActionWithdrawBankMyNameActionBankWithdrawPost(ctx context.Context, request *SimpleItemSchema, params ActionWithdrawBankMyNameActionBankWithdrawPostParams) (ActionWithdrawBankMyNameActionBankWithdrawPostRes, error) {
	res, err := c.sendActionWithdrawBankMyNameActionBankWithdrawPost(ctx, request, params)
	return res, err
}

func (c *Client) sendActionWithdrawBankMyNameActionBankWithdrawPost(ctx context.Context, request *SimpleItemSchema, params ActionWithdrawBankMyNameActionBankWithdrawPostParams) (res ActionWithdrawBankMyNameActionBankWithdrawPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("action_withdraw_bank_my__name__action_bank_withdraw_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/{name}/action/bank/withdraw"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ActionWithdrawBankMyNameActionBankWithdrawPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/action/bank/withdraw"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeActionWithdrawBankMyNameActionBankWithdrawPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ActionWithdrawBankMyNameActionBankWithdrawPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeActionWithdrawBankMyNameActionBankWithdrawPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangePasswordMyChangePasswordPost invokes change_password_my_change_password_post operation.
//
// Change your account password. Changing the password reset the account token.
//
// POST /my/change_password
func (c *Client) ChangePasswordMyChangePasswordPost(ctx context.Context, request *ChangePassword) (ChangePasswordMyChangePasswordPostRes, error) {
	res, err := c.sendChangePasswordMyChangePasswordPost(ctx, request)
	return res, err
}

func (c *Client) sendChangePasswordMyChangePasswordPost(ctx context.Context, request *ChangePassword) (res ChangePasswordMyChangePasswordPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("change_password_my_change_password_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/change_password"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChangePasswordMyChangePasswordPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/change_password"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangePasswordMyChangePasswordPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "ChangePasswordMyChangePasswordPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChangePasswordMyChangePasswordPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAccountAccountsCreatePost invokes create_account_accounts_create_post operation.
//
// Create Account.
//
// POST /accounts/create
func (c *Client) CreateAccountAccountsCreatePost(ctx context.Context, request *AddAccountSchema) (CreateAccountAccountsCreatePostRes, error) {
	res, err := c.sendCreateAccountAccountsCreatePost(ctx, request)
	return res, err
}

func (c *Client) sendCreateAccountAccountsCreatePost(ctx context.Context, request *AddAccountSchema) (res CreateAccountAccountsCreatePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_account_accounts_create_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/accounts/create"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateAccountAccountsCreatePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/accounts/create"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAccountAccountsCreatePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAccountAccountsCreatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCharacterCharactersCreatePost invokes create_character_characters_create_post operation.
//
// Create new character on your account. You can create up to 5 characters.
//
// POST /characters/create
func (c *Client) CreateCharacterCharactersCreatePost(ctx context.Context, request *AddCharacterSchema) (CreateCharacterCharactersCreatePostRes, error) {
	res, err := c.sendCreateCharacterCharactersCreatePost(ctx, request)
	return res, err
}

func (c *Client) sendCreateCharacterCharactersCreatePost(ctx context.Context, request *AddCharacterSchema) (res CreateCharacterCharactersCreatePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_character_characters_create_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/characters/create"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateCharacterCharactersCreatePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/characters/create"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateCharacterCharactersCreatePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "CreateCharacterCharactersCreatePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateCharacterCharactersCreatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCharacterCharactersDeletePost invokes delete_character_characters_delete_post operation.
//
// Delete character on your account.
//
// POST /characters/delete
func (c *Client) DeleteCharacterCharactersDeletePost(ctx context.Context, request *DeleteCharacterSchema) (DeleteCharacterCharactersDeletePostRes, error) {
	res, err := c.sendDeleteCharacterCharactersDeletePost(ctx, request)
	return res, err
}

func (c *Client) sendDeleteCharacterCharactersDeletePost(ctx context.Context, request *DeleteCharacterSchema) (res DeleteCharacterCharactersDeletePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_character_characters_delete_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/characters/delete"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteCharacterCharactersDeletePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/characters/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteCharacterCharactersDeletePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "DeleteCharacterCharactersDeletePost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteCharacterCharactersDeletePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateTokenTokenPost invokes generate_token_token_post operation.
//
// Use your account as HTTPBasic Auth to generate your token to use the API. You can also generate
// your token directly on the website.
//
// POST /token
func (c *Client) GenerateTokenTokenPost(ctx context.Context) (GenerateTokenTokenPostRes, error) {
	res, err := c.sendGenerateTokenTokenPost(ctx)
	return res, err
}

func (c *Client) sendGenerateTokenTokenPost(ctx context.Context) (res GenerateTokenTokenPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("generate_token_token_post"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/token"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GenerateTokenTokenPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:HTTPBasic"
			switch err := c.securityHTTPBasic(ctx, "GenerateTokenTokenPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HTTPBasic\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGenerateTokenTokenPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountAccountsAccountGet invokes get_account_accounts__account__get operation.
//
// Retrieve the details of a character.
//
// GET /accounts/{account}
func (c *Client) GetAccountAccountsAccountGet(ctx context.Context, params GetAccountAccountsAccountGetParams) (GetAccountAccountsAccountGetRes, error) {
	res, err := c.sendGetAccountAccountsAccountGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountAccountsAccountGet(ctx context.Context, params GetAccountAccountsAccountGetParams) (res GetAccountAccountsAccountGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_account_accounts__account__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/accounts/{account}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAccountAccountsAccountGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/accounts/"
	{
		// Encode "account" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Account))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAccountAccountsAccountGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountAchievementsAccountsAccountAchievementsGet invokes get_account_achievements_accounts__account__achievements_get operation.
//
// Retrieve the achievements of a account.
//
// GET /accounts/{account}/achievements
func (c *Client) GetAccountAchievementsAccountsAccountAchievementsGet(ctx context.Context, params GetAccountAchievementsAccountsAccountAchievementsGetParams) (GetAccountAchievementsAccountsAccountAchievementsGetRes, error) {
	res, err := c.sendGetAccountAchievementsAccountsAccountAchievementsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountAchievementsAccountsAccountAchievementsGet(ctx context.Context, params GetAccountAchievementsAccountsAccountAchievementsGetParams) (res GetAccountAchievementsAccountsAccountAchievementsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_account_achievements_accounts__account__achievements_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/accounts/{account}/achievements"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAccountAchievementsAccountsAccountAchievementsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/accounts/"
	{
		// Encode "account" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "account",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Account))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/achievements"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "completed" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "completed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Completed.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAccountAchievementsAccountsAccountAchievementsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountDetailsMyDetailsGet invokes get_account_details_my_details_get operation.
//
// Fetch account details.
//
// GET /my/details
func (c *Client) GetAccountDetailsMyDetailsGet(ctx context.Context) (*MyAccountDetailsSchema, error) {
	res, err := c.sendGetAccountDetailsMyDetailsGet(ctx)
	return res, err
}

func (c *Client) sendGetAccountDetailsMyDetailsGet(ctx context.Context) (res *MyAccountDetailsSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_account_details_my_details_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/details"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAccountDetailsMyDetailsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/details"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetAccountDetailsMyDetailsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAccountDetailsMyDetailsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountsLeaderboardLeaderboardAccountsGet invokes get_accounts_leaderboard_leaderboard_accounts_get operation.
//
// Fetch leaderboard details.
//
// GET /leaderboard/accounts
func (c *Client) GetAccountsLeaderboardLeaderboardAccountsGet(ctx context.Context, params GetAccountsLeaderboardLeaderboardAccountsGetParams) (*DataPageAccountLeaderboardSchema, error) {
	res, err := c.sendGetAccountsLeaderboardLeaderboardAccountsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountsLeaderboardLeaderboardAccountsGet(ctx context.Context, params GetAccountsLeaderboardLeaderboardAccountsGetParams) (res *DataPageAccountLeaderboardSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_accounts_leaderboard_leaderboard_accounts_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/leaderboard/accounts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAccountsLeaderboardLeaderboardAccountsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/leaderboard/accounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAccountsLeaderboardLeaderboardAccountsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAchievementAchievementsCodeGet invokes get_achievement_achievements__code__get operation.
//
// Retrieve the details of a achievement.
//
// GET /achievements/{code}
func (c *Client) GetAchievementAchievementsCodeGet(ctx context.Context, params GetAchievementAchievementsCodeGetParams) (GetAchievementAchievementsCodeGetRes, error) {
	res, err := c.sendGetAchievementAchievementsCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAchievementAchievementsCodeGet(ctx context.Context, params GetAchievementAchievementsCodeGetParams) (res GetAchievementAchievementsCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_achievement_achievements__code__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/achievements/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAchievementAchievementsCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/achievements/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAchievementAchievementsCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllAchievementsAchievementsGet invokes get_all_achievements_achievements_get operation.
//
// List of all achievements.
//
// GET /achievements
func (c *Client) GetAllAchievementsAchievementsGet(ctx context.Context, params GetAllAchievementsAchievementsGetParams) (*DataPageAchievementSchema, error) {
	res, err := c.sendGetAllAchievementsAchievementsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllAchievementsAchievementsGet(ctx context.Context, params GetAllAchievementsAchievementsGetParams) (res *DataPageAchievementSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_achievements_achievements_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/achievements"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllAchievementsAchievementsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/achievements"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllAchievementsAchievementsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllActiveEventsEventsActiveGet invokes get_all_active_events_events_active_get operation.
//
// Fetch active events details.
//
// GET /events/active
func (c *Client) GetAllActiveEventsEventsActiveGet(ctx context.Context, params GetAllActiveEventsEventsActiveGetParams) (*DataPageActiveEventSchema, error) {
	res, err := c.sendGetAllActiveEventsEventsActiveGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllActiveEventsEventsActiveGet(ctx context.Context, params GetAllActiveEventsEventsActiveGetParams) (res *DataPageActiveEventSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_active_events_events_active_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/events/active"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllActiveEventsEventsActiveGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/events/active"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllActiveEventsEventsActiveGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllBadgesBadgesGet invokes get_all_badges_badges_get operation.
//
// List of all badges.
//
// GET /badges
func (c *Client) GetAllBadgesBadgesGet(ctx context.Context, params GetAllBadgesBadgesGetParams) (*DataPageBadgeSchema, error) {
	res, err := c.sendGetAllBadgesBadgesGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllBadgesBadgesGet(ctx context.Context, params GetAllBadgesBadgesGetParams) (res *DataPageBadgeSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_badges_badges_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/badges"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllBadgesBadgesGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/badges"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllBadgesBadgesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllCharactersLogsMyLogsGet invokes get_all_characters_logs_my_logs_get operation.
//
// History of the last 100 actions of all your characters.
//
// GET /my/logs
func (c *Client) GetAllCharactersLogsMyLogsGet(ctx context.Context, params GetAllCharactersLogsMyLogsGetParams) (GetAllCharactersLogsMyLogsGetRes, error) {
	res, err := c.sendGetAllCharactersLogsMyLogsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllCharactersLogsMyLogsGet(ctx context.Context, params GetAllCharactersLogsMyLogsGetParams) (res GetAllCharactersLogsMyLogsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_characters_logs_my_logs_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllCharactersLogsMyLogsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetAllCharactersLogsMyLogsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllCharactersLogsMyLogsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllEventsEventsGet invokes get_all_events_events_get operation.
//
// Fetch events details.
//
// GET /events
func (c *Client) GetAllEventsEventsGet(ctx context.Context, params GetAllEventsEventsGetParams) (*DataPageEventSchema, error) {
	res, err := c.sendGetAllEventsEventsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllEventsEventsGet(ctx context.Context, params GetAllEventsEventsGetParams) (res *DataPageEventSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_events_events_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/events"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllEventsEventsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllEventsEventsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllItemsItemsGet invokes get_all_items_items_get operation.
//
// Fetch items details.
//
// GET /items
func (c *Client) GetAllItemsItemsGet(ctx context.Context, params GetAllItemsItemsGetParams) (*DataPageItemSchema, error) {
	res, err := c.sendGetAllItemsItemsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllItemsItemsGet(ctx context.Context, params GetAllItemsItemsGetParams) (res *DataPageItemSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_items_items_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/items"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllItemsItemsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "min_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "max_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "max_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "craft_skill" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "craft_skill",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CraftSkill.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "craft_material" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "craft_material",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CraftMaterial.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllItemsItemsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllMapsMapsGet invokes get_all_maps_maps_get operation.
//
// Fetch maps details.
//
// GET /maps
func (c *Client) GetAllMapsMapsGet(ctx context.Context, params GetAllMapsMapsGetParams) (*DataPageMapSchema, error) {
	res, err := c.sendGetAllMapsMapsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllMapsMapsGet(ctx context.Context, params GetAllMapsMapsGetParams) (res *DataPageMapSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_maps_maps_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/maps"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllMapsMapsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/maps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "content_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ContentType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "content_code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "content_code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ContentCode.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllMapsMapsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllMonstersMonstersGet invokes get_all_monsters_monsters_get operation.
//
// Fetch monsters details.
//
// GET /monsters
func (c *Client) GetAllMonstersMonstersGet(ctx context.Context, params GetAllMonstersMonstersGetParams) (*DataPageMonsterSchema, error) {
	res, err := c.sendGetAllMonstersMonstersGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllMonstersMonstersGet(ctx context.Context, params GetAllMonstersMonstersGetParams) (res *DataPageMonsterSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_monsters_monsters_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/monsters"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllMonstersMonstersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/monsters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "min_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "max_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "max_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "drop" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "drop",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Drop.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllMonstersMonstersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllResourcesResourcesGet invokes get_all_resources_resources_get operation.
//
// Fetch resources details.
//
// GET /resources
func (c *Client) GetAllResourcesResourcesGet(ctx context.Context, params GetAllResourcesResourcesGetParams) (*DataPageResourceSchema, error) {
	res, err := c.sendGetAllResourcesResourcesGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllResourcesResourcesGet(ctx context.Context, params GetAllResourcesResourcesGetParams) (res *DataPageResourceSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_resources_resources_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/resources"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllResourcesResourcesGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/resources"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "min_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "max_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "max_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "skill" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "skill",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Skill.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "drop" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "drop",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Drop.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllResourcesResourcesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllTasksRewardsTasksRewardsGet invokes get_all_tasks_rewards_tasks_rewards_get operation.
//
// Fetch the list of all tasks rewards. To obtain these rewards, you must exchange 6 task coins with
// a tasks master.
//
// GET /tasks/rewards
func (c *Client) GetAllTasksRewardsTasksRewardsGet(ctx context.Context, params GetAllTasksRewardsTasksRewardsGetParams) (*DataPageDropRateSchema, error) {
	res, err := c.sendGetAllTasksRewardsTasksRewardsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllTasksRewardsTasksRewardsGet(ctx context.Context, params GetAllTasksRewardsTasksRewardsGetParams) (res *DataPageDropRateSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_tasks_rewards_tasks_rewards_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tasks/rewards"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllTasksRewardsTasksRewardsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tasks/rewards"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllTasksRewardsTasksRewardsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllTasksTasksListGet invokes get_all_tasks_tasks_list_get operation.
//
// Fetch the list of all tasks.
//
// GET /tasks/list
func (c *Client) GetAllTasksTasksListGet(ctx context.Context, params GetAllTasksTasksListGetParams) (*DataPageTaskFullSchema, error) {
	res, err := c.sendGetAllTasksTasksListGet(ctx, params)
	return res, err
}

func (c *Client) sendGetAllTasksTasksListGet(ctx context.Context, params GetAllTasksTasksListGetParams) (res *DataPageTaskFullSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_tasks_tasks_list_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tasks/list"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAllTasksTasksListGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tasks/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "min_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "max_level" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "max_level",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxLevel.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "skill" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "skill",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Skill.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllTasksTasksListGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBadgeBadgesCodeGet invokes get_badge_badges__code__get operation.
//
// Retrieve the details of a badge.
//
// GET /badges/{code}
func (c *Client) GetBadgeBadgesCodeGet(ctx context.Context, params GetBadgeBadgesCodeGetParams) (GetBadgeBadgesCodeGetRes, error) {
	res, err := c.sendGetBadgeBadgesCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetBadgeBadgesCodeGet(ctx context.Context, params GetBadgeBadgesCodeGetParams) (res GetBadgeBadgesCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_badge_badges__code__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/badges/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBadgeBadgesCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/badges/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBadgeBadgesCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBankDetailsMyBankGet invokes get_bank_details_my_bank_get operation.
//
// Fetch bank details.
//
// GET /my/bank
func (c *Client) GetBankDetailsMyBankGet(ctx context.Context) (*BankResponseSchema, error) {
	res, err := c.sendGetBankDetailsMyBankGet(ctx)
	return res, err
}

func (c *Client) sendGetBankDetailsMyBankGet(ctx context.Context) (res *BankResponseSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_bank_details_my_bank_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/bank"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBankDetailsMyBankGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/bank"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetBankDetailsMyBankGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBankDetailsMyBankGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBankItemsMyBankItemsGet invokes get_bank_items_my_bank_items_get operation.
//
// Fetch all items in your bank.
//
// GET /my/bank/items
func (c *Client) GetBankItemsMyBankItemsGet(ctx context.Context, params GetBankItemsMyBankItemsGetParams) (*DataPageSimpleItemSchema, error) {
	res, err := c.sendGetBankItemsMyBankItemsGet(ctx, params)
	return res, err
}

func (c *Client) sendGetBankItemsMyBankItemsGet(ctx context.Context, params GetBankItemsMyBankItemsGetParams) (res *DataPageSimpleItemSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_bank_items_my_bank_items_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/bank/items"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetBankItemsMyBankItemsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/bank/items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "item_code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "item_code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemCode.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetBankItemsMyBankItemsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBankItemsMyBankItemsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCharacterCharactersNameGet invokes get_character_characters__name__get operation.
//
// Retrieve the details of a character.
//
// GET /characters/{name}
func (c *Client) GetCharacterCharactersNameGet(ctx context.Context, params GetCharacterCharactersNameGetParams) (GetCharacterCharactersNameGetRes, error) {
	res, err := c.sendGetCharacterCharactersNameGet(ctx, params)
	return res, err
}

func (c *Client) sendGetCharacterCharactersNameGet(ctx context.Context, params GetCharacterCharactersNameGetParams) (res GetCharacterCharactersNameGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_character_characters__name__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/characters/{name}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCharacterCharactersNameGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/characters/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCharacterCharactersNameGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCharactersLeaderboardLeaderboardCharactersGet invokes get_characters_leaderboard_leaderboard_characters_get operation.
//
// Fetch leaderboard details.
//
// GET /leaderboard/characters
func (c *Client) GetCharactersLeaderboardLeaderboardCharactersGet(ctx context.Context, params GetCharactersLeaderboardLeaderboardCharactersGetParams) (*DataPageCharacterLeaderboardSchema, error) {
	res, err := c.sendGetCharactersLeaderboardLeaderboardCharactersGet(ctx, params)
	return res, err
}

func (c *Client) sendGetCharactersLeaderboardLeaderboardCharactersGet(ctx context.Context, params GetCharactersLeaderboardLeaderboardCharactersGetParams) (res *DataPageCharacterLeaderboardSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_characters_leaderboard_leaderboard_characters_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/leaderboard/characters"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetCharactersLeaderboardLeaderboardCharactersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/leaderboard/characters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCharactersLeaderboardLeaderboardCharactersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGeSellHistoryGrandexchangeHistoryCodeGet invokes get_ge_sell_history_grandexchange_history__code__get operation.
//
// Fetch the sales history of the item for the last 7 days.
//
// GET /grandexchange/history/{code}
func (c *Client) GetGeSellHistoryGrandexchangeHistoryCodeGet(ctx context.Context, params GetGeSellHistoryGrandexchangeHistoryCodeGetParams) (GetGeSellHistoryGrandexchangeHistoryCodeGetRes, error) {
	res, err := c.sendGetGeSellHistoryGrandexchangeHistoryCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetGeSellHistoryGrandexchangeHistoryCodeGet(ctx context.Context, params GetGeSellHistoryGrandexchangeHistoryCodeGetParams) (res GetGeSellHistoryGrandexchangeHistoryCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_ge_sell_history_grandexchange_history__code__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/grandexchange/history/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGeSellHistoryGrandexchangeHistoryCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/grandexchange/history/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "seller" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "seller",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Seller.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "buyer" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "buyer",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Buyer.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGeSellHistoryGrandexchangeHistoryCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGeSellHistoryMyGrandexchangeHistoryGet invokes get_ge_sell_history_my_grandexchange_history_get operation.
//
// Fetch your sales history of the last 7 days.
//
// GET /my/grandexchange/history
func (c *Client) GetGeSellHistoryMyGrandexchangeHistoryGet(ctx context.Context, params GetGeSellHistoryMyGrandexchangeHistoryGetParams) (*DataPageGeOrderHistorySchema, error) {
	res, err := c.sendGetGeSellHistoryMyGrandexchangeHistoryGet(ctx, params)
	return res, err
}

func (c *Client) sendGetGeSellHistoryMyGrandexchangeHistoryGet(ctx context.Context, params GetGeSellHistoryMyGrandexchangeHistoryGetParams) (res *DataPageGeOrderHistorySchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_ge_sell_history_my_grandexchange_history_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/grandexchange/history"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGeSellHistoryMyGrandexchangeHistoryGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/grandexchange/history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Code.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetGeSellHistoryMyGrandexchangeHistoryGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGeSellHistoryMyGrandexchangeHistoryGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGeSellOrderGrandexchangeOrdersIDGet invokes get_ge_sell_order_grandexchange_orders__id__get operation.
//
// Retrieve the sell order of a item.
//
// GET /grandexchange/orders/{id}
func (c *Client) GetGeSellOrderGrandexchangeOrdersIDGet(ctx context.Context, params GetGeSellOrderGrandexchangeOrdersIDGetParams) (GetGeSellOrderGrandexchangeOrdersIDGetRes, error) {
	res, err := c.sendGetGeSellOrderGrandexchangeOrdersIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGetGeSellOrderGrandexchangeOrdersIDGet(ctx context.Context, params GetGeSellOrderGrandexchangeOrdersIDGetParams) (res GetGeSellOrderGrandexchangeOrdersIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_ge_sell_order_grandexchange_orders__id__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/grandexchange/orders/{id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGeSellOrderGrandexchangeOrdersIDGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/grandexchange/orders/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGeSellOrderGrandexchangeOrdersIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGeSellOrdersGrandexchangeOrdersGet invokes get_ge_sell_orders_grandexchange_orders_get operation.
//
// Fetch all sell orders.
//
// GET /grandexchange/orders
func (c *Client) GetGeSellOrdersGrandexchangeOrdersGet(ctx context.Context, params GetGeSellOrdersGrandexchangeOrdersGetParams) (*DataPageGEOrderSchema, error) {
	res, err := c.sendGetGeSellOrdersGrandexchangeOrdersGet(ctx, params)
	return res, err
}

func (c *Client) sendGetGeSellOrdersGrandexchangeOrdersGet(ctx context.Context, params GetGeSellOrdersGrandexchangeOrdersGetParams) (res *DataPageGEOrderSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_ge_sell_orders_grandexchange_orders_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/grandexchange/orders"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGeSellOrdersGrandexchangeOrdersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/grandexchange/orders"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Code.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "seller" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "seller",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Seller.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGeSellOrdersGrandexchangeOrdersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGeSellOrdersMyGrandexchangeOrdersGet invokes get_ge_sell_orders_my_grandexchange_orders_get operation.
//
// Fetch your sell orders details.
//
// GET /my/grandexchange/orders
func (c *Client) GetGeSellOrdersMyGrandexchangeOrdersGet(ctx context.Context, params GetGeSellOrdersMyGrandexchangeOrdersGetParams) (*DataPageGEOrderSchema, error) {
	res, err := c.sendGetGeSellOrdersMyGrandexchangeOrdersGet(ctx, params)
	return res, err
}

func (c *Client) sendGetGeSellOrdersMyGrandexchangeOrdersGet(ctx context.Context, params GetGeSellOrdersMyGrandexchangeOrdersGetParams) (res *DataPageGEOrderSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_ge_sell_orders_my_grandexchange_orders_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/grandexchange/orders"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGeSellOrdersMyGrandexchangeOrdersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/grandexchange/orders"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Code.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetGeSellOrdersMyGrandexchangeOrdersGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGeSellOrdersMyGrandexchangeOrdersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetItemItemsCodeGet invokes get_item_items__code__get operation.
//
// Retrieve the details of a item.
//
// GET /items/{code}
func (c *Client) GetItemItemsCodeGet(ctx context.Context, params GetItemItemsCodeGetParams) (GetItemItemsCodeGetRes, error) {
	res, err := c.sendGetItemItemsCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetItemItemsCodeGet(ctx context.Context, params GetItemItemsCodeGetParams) (res GetItemItemsCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_item_items__code__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/items/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetItemItemsCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/items/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetItemItemsCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMapMapsXYGet invokes get_map_maps__x___y__get operation.
//
// Retrieve the details of a map.
//
// GET /maps/{x}/{y}
func (c *Client) GetMapMapsXYGet(ctx context.Context, params GetMapMapsXYGetParams) (GetMapMapsXYGetRes, error) {
	res, err := c.sendGetMapMapsXYGet(ctx, params)
	return res, err
}

func (c *Client) sendGetMapMapsXYGet(ctx context.Context, params GetMapMapsXYGetParams) (res GetMapMapsXYGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_map_maps__x___y__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/maps/{x}/{y}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMapMapsXYGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/maps/"
	{
		// Encode "x" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "x",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.X))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "y" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "y",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.Y))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMapMapsXYGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMonsterMonstersCodeGet invokes get_monster_monsters__code__get operation.
//
// Retrieve the details of a monster.
//
// GET /monsters/{code}
func (c *Client) GetMonsterMonstersCodeGet(ctx context.Context, params GetMonsterMonstersCodeGetParams) (GetMonsterMonstersCodeGetRes, error) {
	res, err := c.sendGetMonsterMonstersCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetMonsterMonstersCodeGet(ctx context.Context, params GetMonsterMonstersCodeGetParams) (res GetMonsterMonstersCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_monster_monsters__code__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/monsters/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMonsterMonstersCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/monsters/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMonsterMonstersCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyCharactersMyCharactersGet invokes get_my_characters_my_characters_get operation.
//
// List of your characters.
//
// GET /my/characters
func (c *Client) GetMyCharactersMyCharactersGet(ctx context.Context) (*MyCharactersListSchema, error) {
	res, err := c.sendGetMyCharactersMyCharactersGet(ctx)
	return res, err
}

func (c *Client) sendGetMyCharactersMyCharactersGet(ctx context.Context) (res *MyCharactersListSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_my_characters_my_characters_get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/characters"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMyCharactersMyCharactersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/characters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTBearer"
			switch err := c.securityJWTBearer(ctx, "GetMyCharactersMyCharactersGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyCharactersMyCharactersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResourceResourcesCodeGet invokes get_resource_resources__code__get operation.
//
// Retrieve the details of a resource.
//
// GET /resources/{code}
func (c *Client) GetResourceResourcesCodeGet(ctx context.Context, params GetResourceResourcesCodeGetParams) (GetResourceResourcesCodeGetRes, error) {
	res, err := c.sendGetResourceResourcesCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetResourceResourcesCodeGet(ctx context.Context, params GetResourceResourcesCodeGetParams) (res GetResourceResourcesCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_resource_resources__code__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/resources/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetResourceResourcesCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/resources/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetResourceResourcesCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStatusGet invokes get_status__get operation.
//
// Return the status of the game server.
//
// GET /
func (c *Client) GetStatusGet(ctx context.Context) (*StatusResponseSchema, error) {
	res, err := c.sendGetStatusGet(ctx)
	return res, err
}

func (c *Client) sendGetStatusGet(ctx context.Context) (res *StatusResponseSchema, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_status__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStatusGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTaskTasksListCodeGet invokes get_task_tasks_list__code__get operation.
//
// Retrieve the details of a task.
//
// GET /tasks/list/{code}
func (c *Client) GetTaskTasksListCodeGet(ctx context.Context, params GetTaskTasksListCodeGetParams) (GetTaskTasksListCodeGetRes, error) {
	res, err := c.sendGetTaskTasksListCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetTaskTasksListCodeGet(ctx context.Context, params GetTaskTasksListCodeGetParams) (res GetTaskTasksListCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_task_tasks_list__code__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tasks/list/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetTaskTasksListCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tasks/list/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTaskTasksListCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTasksRewardTasksRewardsCodeGet invokes get_tasks_reward_tasks_rewards__code__get operation.
//
// Retrieve the details of a tasks reward.
//
// GET /tasks/rewards/{code}
func (c *Client) GetTasksRewardTasksRewardsCodeGet(ctx context.Context, params GetTasksRewardTasksRewardsCodeGetParams) (GetTasksRewardTasksRewardsCodeGetRes, error) {
	res, err := c.sendGetTasksRewardTasksRewardsCodeGet(ctx, params)
	return res, err
}

func (c *Client) sendGetTasksRewardTasksRewardsCodeGet(ctx context.Context, params GetTasksRewardTasksRewardsCodeGetParams) (res GetTasksRewardTasksRewardsCodeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_tasks_reward_tasks_rewards__code__get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tasks/rewards/{code}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetTasksRewardTasksRewardsCodeGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tasks/rewards/"
	{
		// Encode "code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTasksRewardTasksRewardsCodeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
