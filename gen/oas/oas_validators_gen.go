// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"fmt"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/validate"
)

func (s *AccountAchievementSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s AccountAchievementSchemaType) Validate() error {
	switch s {
	case "combat_kill":
		return nil
	case "combat_drop":
		return nil
	case "combat_level":
		return nil
	case "gathering":
		return nil
	case "crafting":
		return nil
	case "recycling":
		return nil
	case "task":
		return nil
	case "other":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *AccountDetails) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Status.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "status",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *AccountDetailsSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s AccountDetailsStatus) Validate() error {
	switch s {
	case "standard":
		return nil
	case "founder":
		return nil
	case "gold_founder":
		return nil
	case "vip_founder":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *AccountLeaderboardSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Status.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "status",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s AccountLeaderboardSchemaStatus) Validate() error {
	switch s {
	case "standard":
		return nil
	case "founder":
		return nil
	case "gold_founder":
		return nil
	case "vip_founder":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *AchievementResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *AchievementSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s AchievementSchemaType) Validate() error {
	switch s {
	case "combat_kill":
		return nil
	case "combat_drop":
		return nil
	case "combat_level":
		return nil
	case "gathering":
		return nil
	case "crafting":
		return nil
	case "recycling":
		return nil
	case "task":
		return nil
	case "other":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *AddAccountSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    6,
			MinLengthSet: true,
			MaxLength:    32,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Username)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "username",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.String{
			MinLength:    5,
			MinLengthSet: true,
			MaxLength:    50,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[^ \f\n\r\t\v\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+$"],
		}).Validate(string(s.Password)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "password",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Email.Get(); ok {
			if err := func() error {
				if err := (validate.String{
					MinLength:    0,
					MinLengthSet: false,
					MaxLength:    0,
					MaxLengthSet: false,
					Email:        true,
					Hostname:     false,
					Regex:        nil,
				}).Validate(string(value)); err != nil {
					return errors.Wrap(err, "string")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "email",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *AddCharacterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    3,
			MinLengthSet: true,
			MaxLength:    12,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Name)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "name",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s AddCharacterSchemaSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BadgeResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BadgeSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Conditions == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "conditions",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankExtensionTransactionResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankExtensionTransactionSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Transaction.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "transaction",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankExtensionTransactionSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankExtensionTransactionSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankExtensionTransactionSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankExtensionTransactionSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankExtensionTransactionSchemaTransaction) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Price)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankGoldTransactionResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankGoldTransactionSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Bank.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "bank",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankGoldTransactionSchemaBank) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankGoldTransactionSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankGoldTransactionSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankGoldTransactionSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankGoldTransactionSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankItemTransactionResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankItemTransactionSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Item.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "item",
			Error: err,
		})
	}
	if err := func() error {
		if s.Bank == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Bank {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "bank",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankItemTransactionSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankItemTransactionSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankItemTransactionSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankItemTransactionSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *BankItemTransactionSchemaItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Level)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "level",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Craft.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "craft",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s BankItemTransactionSchemaItemCraft) Validate() error {
	switch s.Type {
	case CraftSchemaBankItemTransactionSchemaItemCraft:
		if err := s.CraftSchema.Validate(); err != nil {
			return err
		}
		return nil
	case NullBankItemTransactionSchemaItemCraft:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *BankResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *BankSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Slots)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "slots",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Expansions)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "expansions",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.NextExpansionCost)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "next_expansion_cost",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Gold)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "gold",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ChangePassword) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    5,
			MinLengthSet: true,
			MaxLength:    50,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[^ \f\n\r\t\v\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+$"],
		}).Validate(string(s.CurrentPassword)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "current_password",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.String{
			MinLength:    5,
			MinLengthSet: true,
			MaxLength:    50,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[^ \f\n\r\t\v\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+$"],
		}).Validate(string(s.NewPassword)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "new_password",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterFightDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Fight.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "fight",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterFightDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterFightDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterFightDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterFightDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterFightDataSchemaFight) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Drops == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "drops",
			Error: err,
		})
	}
	if err := func() error {
		if s.Logs == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "logs",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Result.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "result",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterFightDataSchemaFightResult) Validate() error {
	switch s {
	case "win":
		return nil
	case "loss":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterFightResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterMovementDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterMovementDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterMovementDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterMovementDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterMovementDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterMovementResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterRestDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterRestDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterRestDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterRestDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterRestDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CharacterRestResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *CharacterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CharacterSchemaSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CraftSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if value, ok := s.Skill.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skill",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Items {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s CraftSchemaSkill) Validate() error {
	switch s {
	case "weaponcrafting":
		return nil
	case "gearcrafting":
		return nil
	case "jewelrycrafting":
		return nil
	case "cooking":
		return nil
	case "woodcutting":
		return nil
	case "mining":
		return nil
	case "alchemy":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *CraftingSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Quantity.Get(); ok {
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        false,
					Max:           0,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(value)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DataPageAccountAchievementSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageAccountAchievementSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageAccountAchievementSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAccountAchievementSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAccountAchievementSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageAccountAchievementSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAccountAchievementSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAccountAchievementSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageAccountAchievementSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAccountAchievementSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAccountAchievementSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageAccountAchievementSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAccountAchievementSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageAccountLeaderboardSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageAccountLeaderboardSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageAccountLeaderboardSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAccountLeaderboardSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAccountLeaderboardSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageAccountLeaderboardSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAccountLeaderboardSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAccountLeaderboardSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageAccountLeaderboardSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAccountLeaderboardSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAccountLeaderboardSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageAccountLeaderboardSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAccountLeaderboardSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageAchievementSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageAchievementSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageAchievementSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAchievementSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAchievementSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageAchievementSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAchievementSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAchievementSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageAchievementSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAchievementSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageAchievementSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageAchievementSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageAchievementSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageActiveEventSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageActiveEventSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageActiveEventSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageActiveEventSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageActiveEventSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageActiveEventSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageActiveEventSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageActiveEventSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageActiveEventSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageActiveEventSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageActiveEventSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageActiveEventSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageActiveEventSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageBadgeSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageBadgeSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageBadgeSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageBadgeSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageBadgeSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageBadgeSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageBadgeSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageBadgeSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageBadgeSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageBadgeSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageBadgeSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageBadgeSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageBadgeSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageCharacterLeaderboardSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageCharacterLeaderboardSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageCharacterLeaderboardSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageCharacterLeaderboardSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageCharacterLeaderboardSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageCharacterLeaderboardSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageCharacterLeaderboardSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageCharacterLeaderboardSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageCharacterLeaderboardSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageDropRateSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageDropRateSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageDropRateSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageDropRateSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageDropRateSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageDropRateSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageDropRateSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageDropRateSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageDropRateSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageDropRateSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageDropRateSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageDropRateSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageDropRateSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageEventSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageEventSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageEventSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageEventSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageEventSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageEventSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageEventSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageEventSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageEventSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageEventSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageEventSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageEventSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageEventSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageGEOrderSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageGEOrderSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageGEOrderSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGEOrderSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGEOrderSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageGEOrderSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGEOrderSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGEOrderSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageGEOrderSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGEOrderSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGEOrderSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageGEOrderSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGEOrderSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageGeOrderHistorySchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageGeOrderHistorySchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageGeOrderHistorySchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGeOrderHistorySchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGeOrderHistorySchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageGeOrderHistorySchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGeOrderHistorySchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGeOrderHistorySchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageGeOrderHistorySchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGeOrderHistorySchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageGeOrderHistorySchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageGeOrderHistorySchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageGeOrderHistorySchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageItemSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageItemSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageItemSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageItemSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageItemSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageItemSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageItemSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageItemSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageItemSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageItemSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageItemSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageItemSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageLogSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageLogSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageLogSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageLogSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageLogSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageLogSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageLogSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageLogSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageLogSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageLogSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageLogSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageLogSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageLogSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageMapSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageMapSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageMapSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMapSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMapSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageMapSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMapSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMapSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageMapSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMapSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMapSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageMapSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMapSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageMonsterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageMonsterSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageMonsterSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMonsterSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMonsterSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageMonsterSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMonsterSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMonsterSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageMonsterSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMonsterSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageMonsterSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageMonsterSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageMonsterSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageResourceSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageResourceSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageResourceSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageResourceSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageResourceSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageResourceSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageResourceSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageResourceSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageResourceSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageResourceSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageResourceSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageResourceSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageResourceSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageSimpleItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageSimpleItemSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageSimpleItemSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageSimpleItemSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageSimpleItemSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageSimpleItemSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageSimpleItemSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageSimpleItemSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageSimpleItemSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageSimpleItemSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageSimpleItemSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DataPageTaskFullSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Total.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Page.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "page",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Size.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "size",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Pages.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "pages",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DataPageTaskFullSchemaPage) Validate() error {
	switch s.Type {
	case IntDataPageTaskFullSchemaPage:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageTaskFullSchemaPage:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageTaskFullSchemaPages) Validate() error {
	switch s.Type {
	case IntDataPageTaskFullSchemaPages:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageTaskFullSchemaPages:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageTaskFullSchemaSize) Validate() error {
	switch s.Type {
	case IntDataPageTaskFullSchemaSize:
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageTaskFullSchemaSize:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DataPageTaskFullSchemaTotal) Validate() error {
	switch s.Type {
	case IntDataPageTaskFullSchemaTotal:
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Int)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	case NullDataPageTaskFullSchemaTotal:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *DeleteCharacterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    3,
			MinLengthSet: true,
			MaxLength:    12,
			MaxLengthSet: true,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Name)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "name",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DeleteItemResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DeleteItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Item.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "item",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DeleteItemSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DeleteItemSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *DeleteItemSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s DeleteItemSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *DeleteItemSchemaItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DepositWithdrawGoldSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *DropRateSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Rate)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "rate",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.MinQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "min_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.MaxQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "max_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *EquipRequestSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Slot.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "slot",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Item.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "item",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *EquipRequestSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EquipRequestSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *EquipRequestSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EquipRequestSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *EquipRequestSchemaItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Level)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "level",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Craft.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "craft",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EquipRequestSchemaItemCraft) Validate() error {
	switch s.Type {
	case CraftSchemaEquipRequestSchemaItemCraft:
		if err := s.CraftSchema.Validate(); err != nil {
			return err
		}
		return nil
	case NullEquipRequestSchemaItemCraft:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s EquipRequestSchemaSlot) Validate() error {
	switch s {
	case "weapon":
		return nil
	case "shield":
		return nil
	case "helmet":
		return nil
	case "body_armor":
		return nil
	case "leg_armor":
		return nil
	case "boots":
		return nil
	case "ring1":
		return nil
	case "ring2":
		return nil
	case "amulet":
		return nil
	case "artifact1":
		return nil
	case "artifact2":
		return nil
	case "artifact3":
		return nil
	case "utility1":
		return nil
	case "utility2":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *EquipSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Slot.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "slot",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Quantity.Get(); ok {
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        true,
					Max:           100,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(value)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EquipSchemaSlot) Validate() error {
	switch s {
	case "weapon":
		return nil
	case "shield":
		return nil
	case "helmet":
		return nil
	case "body_armor":
		return nil
	case "leg_armor":
		return nil
	case "boots":
		return nil
	case "ring1":
		return nil
	case "ring2":
		return nil
	case "amulet":
		return nil
	case "artifact1":
		return nil
	case "artifact2":
		return nil
	case "artifact3":
		return nil
	case "utility1":
		return nil
	case "utility2":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *EquipmentResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *EventSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Maps == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maps",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GEBuyOrderSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        true,
			Max:           100,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GECreateOrderTransactionResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GEOrderCreationrSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        true,
			Max:           100,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        true,
			Max:           1000000000,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Price)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GEOrderReponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GEOrderSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        true,
			Max:           100,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Price)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GEOrderTransactionSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Order.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "order",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GEOrderTransactionSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GEOrderTransactionSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *GEOrderTransactionSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GEOrderTransactionSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *GEOrderTransactionSchemaOrder) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        true,
			Max:           100,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Price)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.TotalPrice)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "total_price",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Tax)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "tax",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GETransactionListSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GETransactionListSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GETransactionListSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *GETransactionListSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GETransactionListSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *GETransactionResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *GeOrderHistorySchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        true,
			Max:           100,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Price)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "price",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s GetAccountAchievementsAccountsAccountAchievementsGetType) Validate() error {
	switch s {
	case "combat_kill":
		return nil
	case "combat_drop":
		return nil
	case "combat_level":
		return nil
	case "gathering":
		return nil
	case "crafting":
		return nil
	case "recycling":
		return nil
	case "task":
		return nil
	case "other":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllAchievementsAchievementsGetType) Validate() error {
	switch s {
	case "combat_kill":
		return nil
	case "combat_drop":
		return nil
	case "combat_level":
		return nil
	case "gathering":
		return nil
	case "crafting":
		return nil
	case "recycling":
		return nil
	case "task":
		return nil
	case "other":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllItemsItemsGetCraftSkill) Validate() error {
	switch s {
	case "weaponcrafting":
		return nil
	case "gearcrafting":
		return nil
	case "jewelrycrafting":
		return nil
	case "cooking":
		return nil
	case "woodcutting":
		return nil
	case "mining":
		return nil
	case "alchemy":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllItemsItemsGetType) Validate() error {
	switch s {
	case "utility":
		return nil
	case "body_armor":
		return nil
	case "weapon":
		return nil
	case "resource":
		return nil
	case "leg_armor":
		return nil
	case "helmet":
		return nil
	case "boots":
		return nil
	case "shield":
		return nil
	case "amulet":
		return nil
	case "ring":
		return nil
	case "artifact":
		return nil
	case "currency":
		return nil
	case "consumable":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllMapsMapsGetContentType) Validate() error {
	switch s {
	case "monster":
		return nil
	case "resource":
		return nil
	case "workshop":
		return nil
	case "bank":
		return nil
	case "grand_exchange":
		return nil
	case "tasks_master":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllResourcesResourcesGetSkill) Validate() error {
	switch s {
	case "mining":
		return nil
	case "woodcutting":
		return nil
	case "fishing":
		return nil
	case "alchemy":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllTasksTasksListGetSkill) Validate() error {
	switch s {
	case "weaponcrafting":
		return nil
	case "gearcrafting":
		return nil
	case "jewelrycrafting":
		return nil
	case "cooking":
		return nil
	case "woodcutting":
		return nil
	case "mining":
		return nil
	case "alchemy":
		return nil
	case "fishing":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetAllTasksTasksListGetType) Validate() error {
	switch s {
	case "monsters":
		return nil
	case "items":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s GetCharactersLeaderboardLeaderboardCharactersGetSort) Validate() error {
	switch s {
	case "combat":
		return nil
	case "woodcutting":
		return nil
	case "mining":
		return nil
	case "fishing":
		return nil
	case "weaponcrafting":
		return nil
	case "gearcrafting":
		return nil
	case "jewelrycrafting":
		return nil
	case "cooking":
		return nil
	case "alchemy":
		return nil
	case "gold":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *ItemResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Level)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "level",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Craft.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "craft",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s ItemSchemaCraft) Validate() error {
	switch s.Type {
	case CraftSchemaItemSchemaCraft:
		if err := s.CraftSchema.Validate(); err != nil {
			return err
		}
		return nil
	case NullItemSchemaCraft:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *LogSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s LogSchemaType) Validate() error {
	switch s {
	case "spawn":
		return nil
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "new_task":
		return nil
	case "task_exchange":
		return nil
	case "task_cancelled":
		return nil
	case "task_completed":
		return nil
	case "task_trade":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	case "achievement":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *MonsterResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *MonsterSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Drops == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Drops {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "drops",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *MyAccountDetails) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        true,
			Hostname:     false,
			Regex:        nil,
		}).Validate(string(s.Email)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "email",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Status.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "status",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *MyAccountDetailsSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s MyAccountDetailsStatus) Validate() error {
	switch s {
	case "standard":
		return nil
	case "founder":
		return nil
	case "gold_founder":
		return nil
	case "vip_founder":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *MyCharactersListSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Data == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Data {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RecyclingDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Details.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "details",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RecyclingDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s RecyclingDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *RecyclingDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s RecyclingDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *RecyclingDataSchemaDetails) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Items == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RecyclingResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RecyclingSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Quantity.Get(); ok {
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        false,
					Max:           0,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(value)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ResourceResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *ResourceSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skill.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skill",
			Error: err,
		})
	}
	if err := func() error {
		if s.Drops == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Drops {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "drops",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s ResourceSchemaSkill) Validate() error {
	switch s {
	case "mining":
		return nil
	case "woodcutting":
		return nil
	case "fishing":
		return nil
	case "alchemy":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *RewardDataResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RewardDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Rewards.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "rewards",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RewardDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s RewardDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *RewardDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s RewardDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *RewardDataSchemaRewards) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Items == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Items {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *RewardResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SimpleItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.String{
			MinLength:    0,
			MinLengthSet: false,
			MaxLength:    0,
			MaxLengthSet: false,
			Email:        false,
			Hostname:     false,
			Regex:        regexMap["^[a-zA-Z0-9_-]+$"],
		}).Validate(string(s.Code)); err != nil {
			return errors.Wrap(err, "string")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "code",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Quantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SkillDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Details.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "details",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SkillDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s SkillDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *SkillDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s SkillDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *SkillDataSchemaDetails) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Items == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SkillResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *StatusResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *StatusSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Announcements == nil {
			return errors.New("nil is invalid value")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "announcements",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskCancelledResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskCancelledSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskCancelledSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskCancelledSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskCancelledSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskCancelledSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Task.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "task",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskDataSchemaTask) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Rewards.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "rewards",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskDataSchemaTaskRewards) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Items == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Items {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskDataSchemaTaskType) Validate() error {
	switch s {
	case "monsters":
		return nil
	case "items":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskFullResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskFullSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Rewards.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "rewards",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskFullSchemaRewards) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Items == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Items {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskFullSchemaType) Validate() error {
	switch s {
	case "monsters":
		return nil
	case "items":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskTradeDataSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TaskTradeDataSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskTradeDataSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskTradeDataSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TaskTradeDataSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *TaskTradeResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *UnequipSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Slot.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "slot",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Quantity.Get(); ok {
			if err := func() error {
				if err := (validate.Int{
					MinSet:        true,
					Min:           1,
					MaxSet:        true,
					Max:           100,
					MinExclusive:  false,
					MaxExclusive:  false,
					MultipleOfSet: false,
					MultipleOf:    0,
				}).Validate(int64(value)); err != nil {
					return errors.Wrap(err, "int")
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s UnequipSchemaSlot) Validate() error {
	switch s {
	case "weapon":
		return nil
	case "shield":
		return nil
	case "helmet":
		return nil
	case "body_armor":
		return nil
	case "leg_armor":
		return nil
	case "boots":
		return nil
	case "ring1":
		return nil
	case "ring2":
		return nil
	case "amulet":
		return nil
	case "artifact1":
		return nil
	case "artifact2":
		return nil
	case "artifact3":
		return nil
	case "utility1":
		return nil
	case "utility2":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *UseItemResponseSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Data.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "data",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *UseItemSchema) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Cooldown.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "cooldown",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Item.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "item",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Character.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "character",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *UseItemSchemaCharacter) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Skin.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "skin",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility1SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility1_slot_quantity",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           0,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Utility2SlotQuantity)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "utility2_slot_quantity",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s UseItemSchemaCharacterSkin) Validate() error {
	switch s {
	case "men1":
		return nil
	case "men2":
		return nil
	case "men3":
		return nil
	case "women1":
		return nil
	case "women2":
		return nil
	case "women3":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *UseItemSchemaCooldown) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Reason.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "reason",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s UseItemSchemaCooldownReason) Validate() error {
	switch s {
	case "movement":
		return nil
	case "fight":
		return nil
	case "crafting":
		return nil
	case "gathering":
		return nil
	case "buy_ge":
		return nil
	case "sell_ge":
		return nil
	case "cancel_ge":
		return nil
	case "delete_item":
		return nil
	case "deposit":
		return nil
	case "withdraw":
		return nil
	case "deposit_gold":
		return nil
	case "withdraw_gold":
		return nil
	case "equip":
		return nil
	case "unequip":
		return nil
	case "task":
		return nil
	case "christmas_exchange":
		return nil
	case "recycling":
		return nil
	case "rest":
		return nil
	case "use":
		return nil
	case "buy_bank_expansion":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}

func (s *UseItemSchemaItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := (validate.Int{
			MinSet:        true,
			Min:           1,
			MaxSet:        false,
			Max:           0,
			MinExclusive:  false,
			MaxExclusive:  false,
			MultipleOfSet: false,
			MultipleOf:    0,
		}).Validate(int64(s.Level)); err != nil {
			return errors.Wrap(err, "int")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "level",
			Error: err,
		})
	}
	if err := func() error {
		if value, ok := s.Craft.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "craft",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s UseItemSchemaItemCraft) Validate() error {
	switch s.Type {
	case CraftSchemaUseItemSchemaItemCraft:
		if err := s.CraftSchema.Validate(); err != nil {
			return err
		}
		return nil
	case NullUseItemSchemaItemCraft:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}
