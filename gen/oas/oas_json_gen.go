// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AccountAchievementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountAchievementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("points")
		e.Int(s.Points)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
	{
		e.FieldStart("current")
		e.Int(s.Current)
	}
	{
		e.FieldStart("completed_at")
		s.CompletedAt.Encode(e)
	}
}

var jsonFieldsNameOfAccountAchievementSchema = [10]string{
	0: "name",
	1: "code",
	2: "description",
	3: "points",
	4: "type",
	5: "target",
	6: "total",
	7: "rewards",
	8: "current",
	9: "completed_at",
}

// Decode decodes AccountAchievementSchema from json.
func (s *AccountAchievementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountAchievementSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "current":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Current = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "completed_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.CompletedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountAchievementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountAchievementSchema) {
					name = jsonFieldsNameOfAccountAchievementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountAchievementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountAchievementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountAchievementSchemaCompletedAt as json.
func (s AccountAchievementSchemaCompletedAt) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeAccountAchievementSchemaCompletedAt:
		json.EncodeDateTime(e, s.DateTime)
	case NullAccountAchievementSchemaCompletedAt:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes AccountAchievementSchemaCompletedAt from json.
func (s *AccountAchievementSchemaCompletedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountAchievementSchemaCompletedAt to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullAccountAchievementSchemaCompletedAt
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeAccountAchievementSchemaCompletedAt
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountAchievementSchemaCompletedAt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountAchievementSchemaCompletedAt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountAchievementSchemaRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountAchievementSchemaRewards) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfAccountAchievementSchemaRewards = [1]string{
	0: "gold",
}

// Decode decodes AccountAchievementSchemaRewards from json.
func (s *AccountAchievementSchemaRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountAchievementSchemaRewards to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gold":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountAchievementSchemaRewards")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountAchievementSchemaRewards) {
					name = jsonFieldsNameOfAccountAchievementSchemaRewards[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountAchievementSchemaRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountAchievementSchemaRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountAchievementSchemaTarget as json.
func (s AccountAchievementSchemaTarget) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringAccountAchievementSchemaTarget:
		e.Str(s.String)
	case NullAccountAchievementSchemaTarget:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes AccountAchievementSchemaTarget from json.
func (s *AccountAchievementSchemaTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountAchievementSchemaTarget to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullAccountAchievementSchemaTarget
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringAccountAchievementSchemaTarget
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountAchievementSchemaTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountAchievementSchemaTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountAchievementSchemaType as json.
func (s AccountAchievementSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccountAchievementSchemaType from json.
func (s *AccountAchievementSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountAchievementSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccountAchievementSchemaType(v) {
	case AccountAchievementSchemaTypeCombatKill:
		*s = AccountAchievementSchemaTypeCombatKill
	case AccountAchievementSchemaTypeCombatDrop:
		*s = AccountAchievementSchemaTypeCombatDrop
	case AccountAchievementSchemaTypeCombatLevel:
		*s = AccountAchievementSchemaTypeCombatLevel
	case AccountAchievementSchemaTypeGathering:
		*s = AccountAchievementSchemaTypeGathering
	case AccountAchievementSchemaTypeCrafting:
		*s = AccountAchievementSchemaTypeCrafting
	case AccountAchievementSchemaTypeRecycling:
		*s = AccountAchievementSchemaTypeRecycling
	case AccountAchievementSchemaTypeTask:
		*s = AccountAchievementSchemaTypeTask
	case AccountAchievementSchemaTypeOther:
		*s = AccountAchievementSchemaTypeOther
	default:
		*s = AccountAchievementSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountAchievementSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountAchievementSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("subscribed")
		e.Bool(s.Subscribed)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Badges.Set {
			e.FieldStart("badges")
			s.Badges.Encode(e)
		}
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("banned")
		e.Bool(s.Banned)
	}
	{
		if s.BanReason.Set {
			e.FieldStart("ban_reason")
			s.BanReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfAccountDetails = [7]string{
	0: "username",
	1: "subscribed",
	2: "status",
	3: "badges",
	4: "achievements_points",
	5: "banned",
	6: "ban_reason",
}

// Decode decodes AccountDetails from json.
func (s *AccountDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "subscribed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Subscribed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribed\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "badges":
			if err := func() error {
				s.Badges.Reset()
				if err := s.Badges.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"badges\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "banned":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Banned = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"banned\"")
			}
		case "ban_reason":
			if err := func() error {
				s.BanReason.Reset()
				if err := s.BanReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ban_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountDetails) {
					name = jsonFieldsNameOfAccountDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountDetailsBadges as json.
func (s AccountDetailsBadges) Encode(e *jx.Encoder) {
	switch s.Type {
	case AnyArrayAccountDetailsBadges:
		e.ArrStart()
		for _, elem := range s.AnyArray {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	case NullAccountDetailsBadges:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes AccountDetailsBadges from json.
func (s *AccountDetailsBadges) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountDetailsBadges to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.AnyArray = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			s.AnyArray = append(s.AnyArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = AnyArrayAccountDetailsBadges
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullAccountDetailsBadges
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountDetailsBadges) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountDetailsBadges) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountDetailsSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountDetailsSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfAccountDetailsSchema = [1]string{
	0: "data",
}

// Decode decodes AccountDetailsSchema from json.
func (s *AccountDetailsSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountDetailsSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountDetailsSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountDetailsSchema) {
					name = jsonFieldsNameOfAccountDetailsSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountDetailsSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountDetailsSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountDetailsStatus as json.
func (s AccountDetailsStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccountDetailsStatus from json.
func (s *AccountDetailsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountDetailsStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccountDetailsStatus(v) {
	case AccountDetailsStatusStandard:
		*s = AccountDetailsStatusStandard
	case AccountDetailsStatusFounder:
		*s = AccountDetailsStatusFounder
	case AccountDetailsStatusGoldFounder:
		*s = AccountDetailsStatusGoldFounder
	case AccountDetailsStatusVipFounder:
		*s = AccountDetailsStatusVipFounder
	default:
		*s = AccountDetailsStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountDetailsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountDetailsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountLeaderboardSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountLeaderboardSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
}

var jsonFieldsNameOfAccountLeaderboardSchema = [4]string{
	0: "position",
	1: "account",
	2: "status",
	3: "achievements_points",
}

// Decode decodes AccountLeaderboardSchema from json.
func (s *AccountLeaderboardSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountLeaderboardSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountLeaderboardSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountLeaderboardSchema) {
					name = jsonFieldsNameOfAccountLeaderboardSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountLeaderboardSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountLeaderboardSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountLeaderboardSchemaStatus as json.
func (s AccountLeaderboardSchemaStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccountLeaderboardSchemaStatus from json.
func (s *AccountLeaderboardSchemaStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountLeaderboardSchemaStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccountLeaderboardSchemaStatus(v) {
	case AccountLeaderboardSchemaStatusStandard:
		*s = AccountLeaderboardSchemaStatusStandard
	case AccountLeaderboardSchemaStatusFounder:
		*s = AccountLeaderboardSchemaStatusFounder
	case AccountLeaderboardSchemaStatusGoldFounder:
		*s = AccountLeaderboardSchemaStatusGoldFounder
	case AccountLeaderboardSchemaStatusVipFounder:
		*s = AccountLeaderboardSchemaStatusVipFounder
	default:
		*s = AccountLeaderboardSchemaStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountLeaderboardSchemaStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountLeaderboardSchemaStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfAchievementResponseSchema = [1]string{
	0: "data",
}

// Decode decodes AchievementResponseSchema from json.
func (s *AchievementResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementResponseSchema) {
					name = jsonFieldsNameOfAchievementResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("points")
		e.Int(s.Points)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("target")
		s.Target.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
}

var jsonFieldsNameOfAchievementSchema = [8]string{
	0: "name",
	1: "code",
	2: "description",
	3: "points",
	4: "type",
	5: "target",
	6: "total",
	7: "rewards",
}

// Decode decodes AchievementSchema from json.
func (s *AchievementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementSchema) {
					name = jsonFieldsNameOfAchievementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AchievementSchemaRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AchievementSchemaRewards) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfAchievementSchemaRewards = [1]string{
	0: "gold",
}

// Decode decodes AchievementSchemaRewards from json.
func (s *AchievementSchemaRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementSchemaRewards to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gold":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AchievementSchemaRewards")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAchievementSchemaRewards) {
					name = jsonFieldsNameOfAchievementSchemaRewards[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AchievementSchemaRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementSchemaRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementSchemaTarget as json.
func (s AchievementSchemaTarget) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringAchievementSchemaTarget:
		e.Str(s.String)
	case NullAchievementSchemaTarget:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes AchievementSchemaTarget from json.
func (s *AchievementSchemaTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementSchemaTarget to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullAchievementSchemaTarget
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringAchievementSchemaTarget
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementSchemaTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementSchemaTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AchievementSchemaType as json.
func (s AchievementSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AchievementSchemaType from json.
func (s *AchievementSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AchievementSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AchievementSchemaType(v) {
	case AchievementSchemaTypeCombatKill:
		*s = AchievementSchemaTypeCombatKill
	case AchievementSchemaTypeCombatDrop:
		*s = AchievementSchemaTypeCombatDrop
	case AchievementSchemaTypeCombatLevel:
		*s = AchievementSchemaTypeCombatLevel
	case AchievementSchemaTypeGathering:
		*s = AchievementSchemaTypeGathering
	case AchievementSchemaTypeCrafting:
		*s = AchievementSchemaTypeCrafting
	case AchievementSchemaTypeRecycling:
		*s = AchievementSchemaTypeRecycling
	case AchievementSchemaTypeTask:
		*s = AchievementSchemaTypeTask
	case AchievementSchemaTypeOther:
		*s = AchievementSchemaTypeOther
	default:
		*s = AchievementSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AchievementSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AchievementSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEventSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEventSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("map")
		s.Map.Encode(e)
	}
	{
		e.FieldStart("previous_skin")
		e.Str(s.PreviousSkin)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfActiveEventSchema = [7]string{
	0: "name",
	1: "code",
	2: "map",
	3: "previous_skin",
	4: "duration",
	5: "expiration",
	6: "created_at",
}

// Decode decodes ActiveEventSchema from json.
func (s *ActiveEventSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEventSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "map":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Map.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"map\"")
			}
		case "previous_skin":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PreviousSkin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_skin\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEventSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEventSchema) {
					name = jsonFieldsNameOfActiveEventSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEventSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEventSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActiveEventSchemaMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActiveEventSchemaMap) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfActiveEventSchemaMap = [5]string{
	0: "name",
	1: "skin",
	2: "x",
	3: "y",
	4: "content",
}

// Decode decodes ActiveEventSchemaMap from json.
func (s *ActiveEventSchemaMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEventSchemaMap to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActiveEventSchemaMap")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActiveEventSchemaMap) {
					name = jsonFieldsNameOfActiveEventSchemaMap[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActiveEventSchemaMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEventSchemaMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActiveEventSchemaMapContent as json.
func (s ActiveEventSchemaMapContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case MapContentSchemaActiveEventSchemaMapContent:
		s.MapContentSchema.Encode(e)
	case NullActiveEventSchemaMapContent:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes ActiveEventSchemaMapContent from json.
func (s *ActiveEventSchemaMapContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActiveEventSchemaMapContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullActiveEventSchemaMapContent
	case jx.Object:
		if err := s.MapContentSchema.Decode(d); err != nil {
			return err
		}
		s.Type = MapContentSchemaActiveEventSchemaMapContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActiveEventSchemaMapContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActiveEventSchemaMapContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddAccountSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddAccountSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfAddAccountSchema = [3]string{
	0: "username",
	1: "password",
	2: "email",
}

// Decode decodes AddAccountSchema from json.
func (s *AddAccountSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddAccountSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddAccountSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddAccountSchema) {
					name = jsonFieldsNameOfAddAccountSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddAccountSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddAccountSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddCharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddCharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
}

var jsonFieldsNameOfAddCharacterSchema = [2]string{
	0: "name",
	1: "skin",
}

// Decode decodes AddCharacterSchema from json.
func (s *AddCharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCharacterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddCharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddCharacterSchema) {
					name = jsonFieldsNameOfAddCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddCharacterSchemaSkin as json.
func (s AddCharacterSchemaSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddCharacterSchemaSkin from json.
func (s *AddCharacterSchemaSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCharacterSchemaSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddCharacterSchemaSkin(v) {
	case AddCharacterSchemaSkinMen1:
		*s = AddCharacterSchemaSkinMen1
	case AddCharacterSchemaSkinMen2:
		*s = AddCharacterSchemaSkinMen2
	case AddCharacterSchemaSkinMen3:
		*s = AddCharacterSchemaSkinMen3
	case AddCharacterSchemaSkinWomen1:
		*s = AddCharacterSchemaSkinWomen1
	case AddCharacterSchemaSkinWomen2:
		*s = AddCharacterSchemaSkinWomen2
	case AddCharacterSchemaSkinWomen3:
		*s = AddCharacterSchemaSkinWomen3
	default:
		*s = AddCharacterSchemaSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddCharacterSchemaSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCharacterSchemaSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnouncementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnouncementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfAnnouncementSchema = [2]string{
	0: "message",
	1: "created_at",
}

// Decode decodes AnnouncementSchema from json.
func (s *AnnouncementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnouncementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnouncementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnouncementSchema) {
					name = jsonFieldsNameOfAnnouncementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnouncementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnouncementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBankExtensionTransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BankExtensionTransactionResponseSchema from json.
func (s *BankExtensionTransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionResponseSchema) {
					name = jsonFieldsNameOfBankExtensionTransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("transaction")
		s.Transaction.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfBankExtensionTransactionSchema = [3]string{
	0: "cooldown",
	1: "transaction",
	2: "character",
}

// Decode decodes BankExtensionTransactionSchema from json.
func (s *BankExtensionTransactionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "transaction":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Transaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionSchema) {
					name = jsonFieldsNameOfBankExtensionTransactionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBankExtensionTransactionSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes BankExtensionTransactionSchemaCharacter from json.
func (s *BankExtensionTransactionSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionSchemaCharacter) {
					name = jsonFieldsNameOfBankExtensionTransactionSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankExtensionTransactionSchemaCharacterSkin as json.
func (s BankExtensionTransactionSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankExtensionTransactionSchemaCharacterSkin from json.
func (s *BankExtensionTransactionSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankExtensionTransactionSchemaCharacterSkin(v) {
	case BankExtensionTransactionSchemaCharacterSkinMen1:
		*s = BankExtensionTransactionSchemaCharacterSkinMen1
	case BankExtensionTransactionSchemaCharacterSkinMen2:
		*s = BankExtensionTransactionSchemaCharacterSkinMen2
	case BankExtensionTransactionSchemaCharacterSkinMen3:
		*s = BankExtensionTransactionSchemaCharacterSkinMen3
	case BankExtensionTransactionSchemaCharacterSkinWomen1:
		*s = BankExtensionTransactionSchemaCharacterSkinWomen1
	case BankExtensionTransactionSchemaCharacterSkinWomen2:
		*s = BankExtensionTransactionSchemaCharacterSkinWomen2
	case BankExtensionTransactionSchemaCharacterSkinWomen3:
		*s = BankExtensionTransactionSchemaCharacterSkinWomen3
	default:
		*s = BankExtensionTransactionSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankExtensionTransactionSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfBankExtensionTransactionSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes BankExtensionTransactionSchemaCooldown from json.
func (s *BankExtensionTransactionSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionSchemaCooldown) {
					name = jsonFieldsNameOfBankExtensionTransactionSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankExtensionTransactionSchemaCooldownReason as json.
func (s BankExtensionTransactionSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankExtensionTransactionSchemaCooldownReason from json.
func (s *BankExtensionTransactionSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankExtensionTransactionSchemaCooldownReason(v) {
	case BankExtensionTransactionSchemaCooldownReasonMovement:
		*s = BankExtensionTransactionSchemaCooldownReasonMovement
	case BankExtensionTransactionSchemaCooldownReasonFight:
		*s = BankExtensionTransactionSchemaCooldownReasonFight
	case BankExtensionTransactionSchemaCooldownReasonCrafting:
		*s = BankExtensionTransactionSchemaCooldownReasonCrafting
	case BankExtensionTransactionSchemaCooldownReasonGathering:
		*s = BankExtensionTransactionSchemaCooldownReasonGathering
	case BankExtensionTransactionSchemaCooldownReasonBuyGe:
		*s = BankExtensionTransactionSchemaCooldownReasonBuyGe
	case BankExtensionTransactionSchemaCooldownReasonSellGe:
		*s = BankExtensionTransactionSchemaCooldownReasonSellGe
	case BankExtensionTransactionSchemaCooldownReasonCancelGe:
		*s = BankExtensionTransactionSchemaCooldownReasonCancelGe
	case BankExtensionTransactionSchemaCooldownReasonDeleteItem:
		*s = BankExtensionTransactionSchemaCooldownReasonDeleteItem
	case BankExtensionTransactionSchemaCooldownReasonDeposit:
		*s = BankExtensionTransactionSchemaCooldownReasonDeposit
	case BankExtensionTransactionSchemaCooldownReasonWithdraw:
		*s = BankExtensionTransactionSchemaCooldownReasonWithdraw
	case BankExtensionTransactionSchemaCooldownReasonDepositGold:
		*s = BankExtensionTransactionSchemaCooldownReasonDepositGold
	case BankExtensionTransactionSchemaCooldownReasonWithdrawGold:
		*s = BankExtensionTransactionSchemaCooldownReasonWithdrawGold
	case BankExtensionTransactionSchemaCooldownReasonEquip:
		*s = BankExtensionTransactionSchemaCooldownReasonEquip
	case BankExtensionTransactionSchemaCooldownReasonUnequip:
		*s = BankExtensionTransactionSchemaCooldownReasonUnequip
	case BankExtensionTransactionSchemaCooldownReasonTask:
		*s = BankExtensionTransactionSchemaCooldownReasonTask
	case BankExtensionTransactionSchemaCooldownReasonRecycling:
		*s = BankExtensionTransactionSchemaCooldownReasonRecycling
	case BankExtensionTransactionSchemaCooldownReasonRest:
		*s = BankExtensionTransactionSchemaCooldownReasonRest
	case BankExtensionTransactionSchemaCooldownReasonUse:
		*s = BankExtensionTransactionSchemaCooldownReasonUse
	case BankExtensionTransactionSchemaCooldownReasonBuyBankExpansion:
		*s = BankExtensionTransactionSchemaCooldownReasonBuyBankExpansion
	default:
		*s = BankExtensionTransactionSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankExtensionTransactionSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankExtensionTransactionSchemaTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankExtensionTransactionSchemaTransaction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
}

var jsonFieldsNameOfBankExtensionTransactionSchemaTransaction = [1]string{
	0: "price",
}

// Decode decodes BankExtensionTransactionSchemaTransaction from json.
func (s *BankExtensionTransactionSchemaTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankExtensionTransactionSchemaTransaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "price":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankExtensionTransactionSchemaTransaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankExtensionTransactionSchemaTransaction) {
					name = jsonFieldsNameOfBankExtensionTransactionSchemaTransaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankExtensionTransactionSchemaTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankExtensionTransactionSchemaTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBankGoldTransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BankGoldTransactionResponseSchema from json.
func (s *BankGoldTransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionResponseSchema) {
					name = jsonFieldsNameOfBankGoldTransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("bank")
		s.Bank.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfBankGoldTransactionSchema = [3]string{
	0: "cooldown",
	1: "bank",
	2: "character",
}

// Decode decodes BankGoldTransactionSchema from json.
func (s *BankGoldTransactionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "bank":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Bank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bank\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionSchema) {
					name = jsonFieldsNameOfBankGoldTransactionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionSchemaBank) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionSchemaBank) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfBankGoldTransactionSchemaBank = [1]string{
	0: "quantity",
}

// Decode decodes BankGoldTransactionSchemaBank from json.
func (s *BankGoldTransactionSchemaBank) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaBank to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quantity":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionSchemaBank")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionSchemaBank) {
					name = jsonFieldsNameOfBankGoldTransactionSchemaBank[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionSchemaBank) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaBank) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBankGoldTransactionSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes BankGoldTransactionSchemaCharacter from json.
func (s *BankGoldTransactionSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionSchemaCharacter) {
					name = jsonFieldsNameOfBankGoldTransactionSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankGoldTransactionSchemaCharacterSkin as json.
func (s BankGoldTransactionSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankGoldTransactionSchemaCharacterSkin from json.
func (s *BankGoldTransactionSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankGoldTransactionSchemaCharacterSkin(v) {
	case BankGoldTransactionSchemaCharacterSkinMen1:
		*s = BankGoldTransactionSchemaCharacterSkinMen1
	case BankGoldTransactionSchemaCharacterSkinMen2:
		*s = BankGoldTransactionSchemaCharacterSkinMen2
	case BankGoldTransactionSchemaCharacterSkinMen3:
		*s = BankGoldTransactionSchemaCharacterSkinMen3
	case BankGoldTransactionSchemaCharacterSkinWomen1:
		*s = BankGoldTransactionSchemaCharacterSkinWomen1
	case BankGoldTransactionSchemaCharacterSkinWomen2:
		*s = BankGoldTransactionSchemaCharacterSkinWomen2
	case BankGoldTransactionSchemaCharacterSkinWomen3:
		*s = BankGoldTransactionSchemaCharacterSkinWomen3
	default:
		*s = BankGoldTransactionSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankGoldTransactionSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankGoldTransactionSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankGoldTransactionSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfBankGoldTransactionSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes BankGoldTransactionSchemaCooldown from json.
func (s *BankGoldTransactionSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankGoldTransactionSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankGoldTransactionSchemaCooldown) {
					name = jsonFieldsNameOfBankGoldTransactionSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankGoldTransactionSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankGoldTransactionSchemaCooldownReason as json.
func (s BankGoldTransactionSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankGoldTransactionSchemaCooldownReason from json.
func (s *BankGoldTransactionSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankGoldTransactionSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankGoldTransactionSchemaCooldownReason(v) {
	case BankGoldTransactionSchemaCooldownReasonMovement:
		*s = BankGoldTransactionSchemaCooldownReasonMovement
	case BankGoldTransactionSchemaCooldownReasonFight:
		*s = BankGoldTransactionSchemaCooldownReasonFight
	case BankGoldTransactionSchemaCooldownReasonCrafting:
		*s = BankGoldTransactionSchemaCooldownReasonCrafting
	case BankGoldTransactionSchemaCooldownReasonGathering:
		*s = BankGoldTransactionSchemaCooldownReasonGathering
	case BankGoldTransactionSchemaCooldownReasonBuyGe:
		*s = BankGoldTransactionSchemaCooldownReasonBuyGe
	case BankGoldTransactionSchemaCooldownReasonSellGe:
		*s = BankGoldTransactionSchemaCooldownReasonSellGe
	case BankGoldTransactionSchemaCooldownReasonCancelGe:
		*s = BankGoldTransactionSchemaCooldownReasonCancelGe
	case BankGoldTransactionSchemaCooldownReasonDeleteItem:
		*s = BankGoldTransactionSchemaCooldownReasonDeleteItem
	case BankGoldTransactionSchemaCooldownReasonDeposit:
		*s = BankGoldTransactionSchemaCooldownReasonDeposit
	case BankGoldTransactionSchemaCooldownReasonWithdraw:
		*s = BankGoldTransactionSchemaCooldownReasonWithdraw
	case BankGoldTransactionSchemaCooldownReasonDepositGold:
		*s = BankGoldTransactionSchemaCooldownReasonDepositGold
	case BankGoldTransactionSchemaCooldownReasonWithdrawGold:
		*s = BankGoldTransactionSchemaCooldownReasonWithdrawGold
	case BankGoldTransactionSchemaCooldownReasonEquip:
		*s = BankGoldTransactionSchemaCooldownReasonEquip
	case BankGoldTransactionSchemaCooldownReasonUnequip:
		*s = BankGoldTransactionSchemaCooldownReasonUnequip
	case BankGoldTransactionSchemaCooldownReasonTask:
		*s = BankGoldTransactionSchemaCooldownReasonTask
	case BankGoldTransactionSchemaCooldownReasonRecycling:
		*s = BankGoldTransactionSchemaCooldownReasonRecycling
	case BankGoldTransactionSchemaCooldownReasonRest:
		*s = BankGoldTransactionSchemaCooldownReasonRest
	case BankGoldTransactionSchemaCooldownReasonUse:
		*s = BankGoldTransactionSchemaCooldownReasonUse
	case BankGoldTransactionSchemaCooldownReasonBuyBankExpansion:
		*s = BankGoldTransactionSchemaCooldownReasonBuyBankExpansion
	default:
		*s = BankGoldTransactionSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankGoldTransactionSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankGoldTransactionSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBankItemTransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BankItemTransactionResponseSchema from json.
func (s *BankItemTransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionResponseSchema) {
					name = jsonFieldsNameOfBankItemTransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("bank")
		e.ArrStart()
		for _, elem := range s.Bank {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfBankItemTransactionSchema = [4]string{
	0: "cooldown",
	1: "item",
	2: "bank",
	3: "character",
}

// Decode decodes BankItemTransactionSchema from json.
func (s *BankItemTransactionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "bank":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Bank = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bank = append(s.Bank, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bank\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionSchema) {
					name = jsonFieldsNameOfBankItemTransactionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBankItemTransactionSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes BankItemTransactionSchemaCharacter from json.
func (s *BankItemTransactionSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionSchemaCharacter) {
					name = jsonFieldsNameOfBankItemTransactionSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemTransactionSchemaCharacterSkin as json.
func (s BankItemTransactionSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankItemTransactionSchemaCharacterSkin from json.
func (s *BankItemTransactionSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankItemTransactionSchemaCharacterSkin(v) {
	case BankItemTransactionSchemaCharacterSkinMen1:
		*s = BankItemTransactionSchemaCharacterSkinMen1
	case BankItemTransactionSchemaCharacterSkinMen2:
		*s = BankItemTransactionSchemaCharacterSkinMen2
	case BankItemTransactionSchemaCharacterSkinMen3:
		*s = BankItemTransactionSchemaCharacterSkinMen3
	case BankItemTransactionSchemaCharacterSkinWomen1:
		*s = BankItemTransactionSchemaCharacterSkinWomen1
	case BankItemTransactionSchemaCharacterSkinWomen2:
		*s = BankItemTransactionSchemaCharacterSkinWomen2
	case BankItemTransactionSchemaCharacterSkinWomen3:
		*s = BankItemTransactionSchemaCharacterSkinWomen3
	default:
		*s = BankItemTransactionSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemTransactionSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfBankItemTransactionSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes BankItemTransactionSchemaCooldown from json.
func (s *BankItemTransactionSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionSchemaCooldown) {
					name = jsonFieldsNameOfBankItemTransactionSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemTransactionSchemaCooldownReason as json.
func (s BankItemTransactionSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BankItemTransactionSchemaCooldownReason from json.
func (s *BankItemTransactionSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BankItemTransactionSchemaCooldownReason(v) {
	case BankItemTransactionSchemaCooldownReasonMovement:
		*s = BankItemTransactionSchemaCooldownReasonMovement
	case BankItemTransactionSchemaCooldownReasonFight:
		*s = BankItemTransactionSchemaCooldownReasonFight
	case BankItemTransactionSchemaCooldownReasonCrafting:
		*s = BankItemTransactionSchemaCooldownReasonCrafting
	case BankItemTransactionSchemaCooldownReasonGathering:
		*s = BankItemTransactionSchemaCooldownReasonGathering
	case BankItemTransactionSchemaCooldownReasonBuyGe:
		*s = BankItemTransactionSchemaCooldownReasonBuyGe
	case BankItemTransactionSchemaCooldownReasonSellGe:
		*s = BankItemTransactionSchemaCooldownReasonSellGe
	case BankItemTransactionSchemaCooldownReasonCancelGe:
		*s = BankItemTransactionSchemaCooldownReasonCancelGe
	case BankItemTransactionSchemaCooldownReasonDeleteItem:
		*s = BankItemTransactionSchemaCooldownReasonDeleteItem
	case BankItemTransactionSchemaCooldownReasonDeposit:
		*s = BankItemTransactionSchemaCooldownReasonDeposit
	case BankItemTransactionSchemaCooldownReasonWithdraw:
		*s = BankItemTransactionSchemaCooldownReasonWithdraw
	case BankItemTransactionSchemaCooldownReasonDepositGold:
		*s = BankItemTransactionSchemaCooldownReasonDepositGold
	case BankItemTransactionSchemaCooldownReasonWithdrawGold:
		*s = BankItemTransactionSchemaCooldownReasonWithdrawGold
	case BankItemTransactionSchemaCooldownReasonEquip:
		*s = BankItemTransactionSchemaCooldownReasonEquip
	case BankItemTransactionSchemaCooldownReasonUnequip:
		*s = BankItemTransactionSchemaCooldownReasonUnequip
	case BankItemTransactionSchemaCooldownReasonTask:
		*s = BankItemTransactionSchemaCooldownReasonTask
	case BankItemTransactionSchemaCooldownReasonRecycling:
		*s = BankItemTransactionSchemaCooldownReasonRecycling
	case BankItemTransactionSchemaCooldownReasonRest:
		*s = BankItemTransactionSchemaCooldownReasonRest
	case BankItemTransactionSchemaCooldownReasonUse:
		*s = BankItemTransactionSchemaCooldownReasonUse
	case BankItemTransactionSchemaCooldownReasonBuyBankExpansion:
		*s = BankItemTransactionSchemaCooldownReasonBuyBankExpansion
	default:
		*s = BankItemTransactionSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemTransactionSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankItemTransactionSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankItemTransactionSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
	{
		e.FieldStart("tradeable")
		e.Bool(s.Tradeable)
	}
}

var jsonFieldsNameOfBankItemTransactionSchemaItem = [9]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
	8: "tradeable",
}

// Decode decodes BankItemTransactionSchemaItem from json.
func (s *BankItemTransactionSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		case "tradeable":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Tradeable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankItemTransactionSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankItemTransactionSchemaItem) {
					name = jsonFieldsNameOfBankItemTransactionSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankItemTransactionSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemTransactionSchemaItemCraft as json.
func (s BankItemTransactionSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaBankItemTransactionSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullBankItemTransactionSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes BankItemTransactionSchemaItemCraft from json.
func (s *BankItemTransactionSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankItemTransactionSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullBankItemTransactionSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaBankItemTransactionSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BankItemTransactionSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankItemTransactionSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBankResponseSchema = [1]string{
	0: "data",
}

// Decode decodes BankResponseSchema from json.
func (s *BankResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankResponseSchema) {
					name = jsonFieldsNameOfBankResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slots")
		e.Int(s.Slots)
	}
	{
		e.FieldStart("expansions")
		e.Int(s.Expansions)
	}
	{
		e.FieldStart("next_expansion_cost")
		e.Int(s.NextExpansionCost)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfBankSchema = [4]string{
	0: "slots",
	1: "expansions",
	2: "next_expansion_cost",
	3: "gold",
}

// Decode decodes BankSchema from json.
func (s *BankSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slots":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Slots = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slots\"")
			}
		case "expansions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Expansions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expansions\"")
			}
		case "next_expansion_cost":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.NextExpansionCost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_expansion_cost\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankSchema) {
					name = jsonFieldsNameOfBankSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChangePassword) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChangePassword) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current_password")
		e.Str(s.CurrentPassword)
	}
	{
		e.FieldStart("new_password")
		e.Str(s.NewPassword)
	}
}

var jsonFieldsNameOfChangePassword = [2]string{
	0: "current_password",
	1: "new_password",
}

// Decode decodes ChangePassword from json.
func (s *ChangePassword) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChangePassword to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_password":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CurrentPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_password\"")
			}
		case "new_password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NewPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChangePassword")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChangePassword) {
					name = jsonFieldsNameOfChangePassword[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChangePassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChangePassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("fight")
		s.Fight.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchema = [3]string{
	0: "cooldown",
	1: "fight",
	2: "character",
}

// Decode decodes CharacterFightDataSchema from json.
func (s *CharacterFightDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "fight":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Fight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fight\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchema) {
					name = jsonFieldsNameOfCharacterFightDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes CharacterFightDataSchemaCharacter from json.
func (s *CharacterFightDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaCharacter) {
					name = jsonFieldsNameOfCharacterFightDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaCharacterSkin as json.
func (s CharacterFightDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaCharacterSkin from json.
func (s *CharacterFightDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaCharacterSkin(v) {
	case CharacterFightDataSchemaCharacterSkinMen1:
		*s = CharacterFightDataSchemaCharacterSkinMen1
	case CharacterFightDataSchemaCharacterSkinMen2:
		*s = CharacterFightDataSchemaCharacterSkinMen2
	case CharacterFightDataSchemaCharacterSkinMen3:
		*s = CharacterFightDataSchemaCharacterSkinMen3
	case CharacterFightDataSchemaCharacterSkinWomen1:
		*s = CharacterFightDataSchemaCharacterSkinWomen1
	case CharacterFightDataSchemaCharacterSkinWomen2:
		*s = CharacterFightDataSchemaCharacterSkinWomen2
	case CharacterFightDataSchemaCharacterSkinWomen3:
		*s = CharacterFightDataSchemaCharacterSkinWomen3
	default:
		*s = CharacterFightDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes CharacterFightDataSchemaCooldown from json.
func (s *CharacterFightDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaCooldown) {
					name = jsonFieldsNameOfCharacterFightDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaCooldownReason as json.
func (s CharacterFightDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaCooldownReason from json.
func (s *CharacterFightDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaCooldownReason(v) {
	case CharacterFightDataSchemaCooldownReasonMovement:
		*s = CharacterFightDataSchemaCooldownReasonMovement
	case CharacterFightDataSchemaCooldownReasonFight:
		*s = CharacterFightDataSchemaCooldownReasonFight
	case CharacterFightDataSchemaCooldownReasonCrafting:
		*s = CharacterFightDataSchemaCooldownReasonCrafting
	case CharacterFightDataSchemaCooldownReasonGathering:
		*s = CharacterFightDataSchemaCooldownReasonGathering
	case CharacterFightDataSchemaCooldownReasonBuyGe:
		*s = CharacterFightDataSchemaCooldownReasonBuyGe
	case CharacterFightDataSchemaCooldownReasonSellGe:
		*s = CharacterFightDataSchemaCooldownReasonSellGe
	case CharacterFightDataSchemaCooldownReasonCancelGe:
		*s = CharacterFightDataSchemaCooldownReasonCancelGe
	case CharacterFightDataSchemaCooldownReasonDeleteItem:
		*s = CharacterFightDataSchemaCooldownReasonDeleteItem
	case CharacterFightDataSchemaCooldownReasonDeposit:
		*s = CharacterFightDataSchemaCooldownReasonDeposit
	case CharacterFightDataSchemaCooldownReasonWithdraw:
		*s = CharacterFightDataSchemaCooldownReasonWithdraw
	case CharacterFightDataSchemaCooldownReasonDepositGold:
		*s = CharacterFightDataSchemaCooldownReasonDepositGold
	case CharacterFightDataSchemaCooldownReasonWithdrawGold:
		*s = CharacterFightDataSchemaCooldownReasonWithdrawGold
	case CharacterFightDataSchemaCooldownReasonEquip:
		*s = CharacterFightDataSchemaCooldownReasonEquip
	case CharacterFightDataSchemaCooldownReasonUnequip:
		*s = CharacterFightDataSchemaCooldownReasonUnequip
	case CharacterFightDataSchemaCooldownReasonTask:
		*s = CharacterFightDataSchemaCooldownReasonTask
	case CharacterFightDataSchemaCooldownReasonRecycling:
		*s = CharacterFightDataSchemaCooldownReasonRecycling
	case CharacterFightDataSchemaCooldownReasonRest:
		*s = CharacterFightDataSchemaCooldownReasonRest
	case CharacterFightDataSchemaCooldownReasonUse:
		*s = CharacterFightDataSchemaCooldownReasonUse
	case CharacterFightDataSchemaCooldownReasonBuyBankExpansion:
		*s = CharacterFightDataSchemaCooldownReasonBuyBankExpansion
	default:
		*s = CharacterFightDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFight) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFight) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("turns")
		e.Int(s.Turns)
	}
	{
		e.FieldStart("monster_blocked_hits")
		s.MonsterBlockedHits.Encode(e)
	}
	{
		e.FieldStart("player_blocked_hits")
		s.PlayerBlockedHits.Encode(e)
	}
	{
		e.FieldStart("logs")
		e.ArrStart()
		for _, elem := range s.Logs {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFight = [8]string{
	0: "xp",
	1: "gold",
	2: "drops",
	3: "turns",
	4: "monster_blocked_hits",
	5: "player_blocked_hits",
	6: "logs",
	7: "result",
}

// Decode decodes CharacterFightDataSchemaFight from json.
func (s *CharacterFightDataSchemaFight) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFight to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "xp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "drops":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Drops = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		case "turns":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Turns = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turns\"")
			}
		case "monster_blocked_hits":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.MonsterBlockedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monster_blocked_hits\"")
			}
		case "player_blocked_hits":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.PlayerBlockedHits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"player_blocked_hits\"")
			}
		case "logs":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Logs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Logs = append(s.Logs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFight")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFight) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFight[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFight) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFight) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fire")
		e.Int(s.Fire)
	}
	{
		e.FieldStart("earth")
		e.Int(s.Earth)
	}
	{
		e.FieldStart("water")
		e.Int(s.Water)
	}
	{
		e.FieldStart("air")
		e.Int(s.Air)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits = [5]string{
	0: "fire",
	1: "earth",
	2: "water",
	3: "air",
	4: "total",
}

// Decode decodes CharacterFightDataSchemaFightMonsterBlockedHits from json.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightMonsterBlockedHits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fire":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Fire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire\"")
			}
		case "earth":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Earth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earth\"")
			}
		case "water":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Water = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"water\"")
			}
		case "air":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Air = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"air\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFightMonsterBlockedHits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFightMonsterBlockedHits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightMonsterBlockedHits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fire")
		e.Int(s.Fire)
	}
	{
		e.FieldStart("earth")
		e.Int(s.Earth)
	}
	{
		e.FieldStart("water")
		e.Int(s.Water)
	}
	{
		e.FieldStart("air")
		e.Int(s.Air)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits = [5]string{
	0: "fire",
	1: "earth",
	2: "water",
	3: "air",
	4: "total",
}

// Decode decodes CharacterFightDataSchemaFightPlayerBlockedHits from json.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightPlayerBlockedHits to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fire":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Fire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire\"")
			}
		case "earth":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Earth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earth\"")
			}
		case "water":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Water = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"water\"")
			}
		case "air":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Air = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"air\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightDataSchemaFightPlayerBlockedHits")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits) {
					name = jsonFieldsNameOfCharacterFightDataSchemaFightPlayerBlockedHits[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightPlayerBlockedHits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterFightDataSchemaFightResult as json.
func (s CharacterFightDataSchemaFightResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterFightDataSchemaFightResult from json.
func (s *CharacterFightDataSchemaFightResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightDataSchemaFightResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterFightDataSchemaFightResult(v) {
	case CharacterFightDataSchemaFightResultWin:
		*s = CharacterFightDataSchemaFightResultWin
	case CharacterFightDataSchemaFightResultLoss:
		*s = CharacterFightDataSchemaFightResultLoss
	default:
		*s = CharacterFightDataSchemaFightResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterFightDataSchemaFightResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightDataSchemaFightResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterFightResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterFightResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterFightResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterFightResponseSchema from json.
func (s *CharacterFightResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterFightResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterFightResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterFightResponseSchema) {
					name = jsonFieldsNameOfCharacterFightResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterFightResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterFightResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterLeaderboardSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterLeaderboardSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("position")
		e.Int(s.Position)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("total_xp")
		e.Int(s.TotalXp)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_total_xp")
		e.Int(s.MiningTotalXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_total_xp")
		e.Int(s.WoodcuttingTotalXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_total_xp")
		e.Int(s.FishingTotalXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_total_xp")
		e.Int(s.WeaponcraftingTotalXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_total_xp")
		e.Int(s.GearcraftingTotalXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_total_xp")
		e.Int(s.JewelrycraftingTotalXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_total_xp")
		e.Int(s.CookingTotalXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_total_xp")
		e.Int(s.AlchemyTotalXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfCharacterLeaderboardSchema = [23]string{
	0:  "position",
	1:  "name",
	2:  "account",
	3:  "skin",
	4:  "level",
	5:  "total_xp",
	6:  "mining_level",
	7:  "mining_total_xp",
	8:  "woodcutting_level",
	9:  "woodcutting_total_xp",
	10: "fishing_level",
	11: "fishing_total_xp",
	12: "weaponcrafting_level",
	13: "weaponcrafting_total_xp",
	14: "gearcrafting_level",
	15: "gearcrafting_total_xp",
	16: "jewelrycrafting_level",
	17: "jewelrycrafting_total_xp",
	18: "cooking_level",
	19: "cooking_total_xp",
	20: "alchemy_level",
	21: "alchemy_total_xp",
	22: "gold",
}

// Decode decodes CharacterLeaderboardSchema from json.
func (s *CharacterLeaderboardSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterLeaderboardSchema to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "total_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_xp\"")
			}
		case "mining_level":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_total_xp":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.MiningTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_total_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_total_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_total_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_total_xp":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.FishingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_total_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_total_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_total_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_total_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_total_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_total_xp":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_total_xp\"")
			}
		case "cooking_level":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_total_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_total_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_total_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyTotalXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_total_xp\"")
			}
		case "gold":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterLeaderboardSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterLeaderboardSchema) {
					name = jsonFieldsNameOfCharacterLeaderboardSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterLeaderboardSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterLeaderboardSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("destination")
		s.Destination.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchema = [3]string{
	0: "cooldown",
	1: "destination",
	2: "character",
}

// Decode decodes CharacterMovementDataSchema from json.
func (s *CharacterMovementDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "destination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Destination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchema) {
					name = jsonFieldsNameOfCharacterMovementDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes CharacterMovementDataSchemaCharacter from json.
func (s *CharacterMovementDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaCharacter) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaCharacterSkin as json.
func (s CharacterMovementDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterMovementDataSchemaCharacterSkin from json.
func (s *CharacterMovementDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterMovementDataSchemaCharacterSkin(v) {
	case CharacterMovementDataSchemaCharacterSkinMen1:
		*s = CharacterMovementDataSchemaCharacterSkinMen1
	case CharacterMovementDataSchemaCharacterSkinMen2:
		*s = CharacterMovementDataSchemaCharacterSkinMen2
	case CharacterMovementDataSchemaCharacterSkinMen3:
		*s = CharacterMovementDataSchemaCharacterSkinMen3
	case CharacterMovementDataSchemaCharacterSkinWomen1:
		*s = CharacterMovementDataSchemaCharacterSkinWomen1
	case CharacterMovementDataSchemaCharacterSkinWomen2:
		*s = CharacterMovementDataSchemaCharacterSkinWomen2
	case CharacterMovementDataSchemaCharacterSkinWomen3:
		*s = CharacterMovementDataSchemaCharacterSkinWomen3
	default:
		*s = CharacterMovementDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes CharacterMovementDataSchemaCooldown from json.
func (s *CharacterMovementDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaCooldown) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaCooldownReason as json.
func (s CharacterMovementDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterMovementDataSchemaCooldownReason from json.
func (s *CharacterMovementDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterMovementDataSchemaCooldownReason(v) {
	case CharacterMovementDataSchemaCooldownReasonMovement:
		*s = CharacterMovementDataSchemaCooldownReasonMovement
	case CharacterMovementDataSchemaCooldownReasonFight:
		*s = CharacterMovementDataSchemaCooldownReasonFight
	case CharacterMovementDataSchemaCooldownReasonCrafting:
		*s = CharacterMovementDataSchemaCooldownReasonCrafting
	case CharacterMovementDataSchemaCooldownReasonGathering:
		*s = CharacterMovementDataSchemaCooldownReasonGathering
	case CharacterMovementDataSchemaCooldownReasonBuyGe:
		*s = CharacterMovementDataSchemaCooldownReasonBuyGe
	case CharacterMovementDataSchemaCooldownReasonSellGe:
		*s = CharacterMovementDataSchemaCooldownReasonSellGe
	case CharacterMovementDataSchemaCooldownReasonCancelGe:
		*s = CharacterMovementDataSchemaCooldownReasonCancelGe
	case CharacterMovementDataSchemaCooldownReasonDeleteItem:
		*s = CharacterMovementDataSchemaCooldownReasonDeleteItem
	case CharacterMovementDataSchemaCooldownReasonDeposit:
		*s = CharacterMovementDataSchemaCooldownReasonDeposit
	case CharacterMovementDataSchemaCooldownReasonWithdraw:
		*s = CharacterMovementDataSchemaCooldownReasonWithdraw
	case CharacterMovementDataSchemaCooldownReasonDepositGold:
		*s = CharacterMovementDataSchemaCooldownReasonDepositGold
	case CharacterMovementDataSchemaCooldownReasonWithdrawGold:
		*s = CharacterMovementDataSchemaCooldownReasonWithdrawGold
	case CharacterMovementDataSchemaCooldownReasonEquip:
		*s = CharacterMovementDataSchemaCooldownReasonEquip
	case CharacterMovementDataSchemaCooldownReasonUnequip:
		*s = CharacterMovementDataSchemaCooldownReasonUnequip
	case CharacterMovementDataSchemaCooldownReasonTask:
		*s = CharacterMovementDataSchemaCooldownReasonTask
	case CharacterMovementDataSchemaCooldownReasonRecycling:
		*s = CharacterMovementDataSchemaCooldownReasonRecycling
	case CharacterMovementDataSchemaCooldownReasonRest:
		*s = CharacterMovementDataSchemaCooldownReasonRest
	case CharacterMovementDataSchemaCooldownReasonUse:
		*s = CharacterMovementDataSchemaCooldownReasonUse
	case CharacterMovementDataSchemaCooldownReasonBuyBankExpansion:
		*s = CharacterMovementDataSchemaCooldownReasonBuyBankExpansion
	default:
		*s = CharacterMovementDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementDataSchemaDestination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementDataSchemaDestination) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementDataSchemaDestination = [5]string{
	0: "name",
	1: "skin",
	2: "x",
	3: "y",
	4: "content",
}

// Decode decodes CharacterMovementDataSchemaDestination from json.
func (s *CharacterMovementDataSchemaDestination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaDestination to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementDataSchemaDestination")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementDataSchemaDestination) {
					name = jsonFieldsNameOfCharacterMovementDataSchemaDestination[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementDataSchemaDestination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaDestination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterMovementDataSchemaDestinationContent as json.
func (s CharacterMovementDataSchemaDestinationContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case MapContentSchemaCharacterMovementDataSchemaDestinationContent:
		s.MapContentSchema.Encode(e)
	case NullCharacterMovementDataSchemaDestinationContent:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes CharacterMovementDataSchemaDestinationContent from json.
func (s *CharacterMovementDataSchemaDestinationContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementDataSchemaDestinationContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullCharacterMovementDataSchemaDestinationContent
	case jx.Object:
		if err := s.MapContentSchema.Decode(d); err != nil {
			return err
		}
		s.Type = MapContentSchemaCharacterMovementDataSchemaDestinationContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterMovementDataSchemaDestinationContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementDataSchemaDestinationContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterMovementResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterMovementResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterMovementResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterMovementResponseSchema from json.
func (s *CharacterMovementResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterMovementResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterMovementResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterMovementResponseSchema) {
					name = jsonFieldsNameOfCharacterMovementResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterMovementResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterMovementResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterResponseSchema from json.
func (s *CharacterResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterResponseSchema) {
					name = jsonFieldsNameOfCharacterResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterRestDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterRestDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("hp_restored")
		e.Int(s.HpRestored)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfCharacterRestDataSchema = [3]string{
	0: "cooldown",
	1: "hp_restored",
	2: "character",
}

// Decode decodes CharacterRestDataSchema from json.
func (s *CharacterRestDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterRestDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "hp_restored":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.HpRestored = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp_restored\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterRestDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterRestDataSchema) {
					name = jsonFieldsNameOfCharacterRestDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterRestDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterRestDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterRestDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterRestDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCharacterRestDataSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes CharacterRestDataSchemaCharacter from json.
func (s *CharacterRestDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterRestDataSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterRestDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterRestDataSchemaCharacter) {
					name = jsonFieldsNameOfCharacterRestDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterRestDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterRestDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterRestDataSchemaCharacterSkin as json.
func (s CharacterRestDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterRestDataSchemaCharacterSkin from json.
func (s *CharacterRestDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterRestDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterRestDataSchemaCharacterSkin(v) {
	case CharacterRestDataSchemaCharacterSkinMen1:
		*s = CharacterRestDataSchemaCharacterSkinMen1
	case CharacterRestDataSchemaCharacterSkinMen2:
		*s = CharacterRestDataSchemaCharacterSkinMen2
	case CharacterRestDataSchemaCharacterSkinMen3:
		*s = CharacterRestDataSchemaCharacterSkinMen3
	case CharacterRestDataSchemaCharacterSkinWomen1:
		*s = CharacterRestDataSchemaCharacterSkinWomen1
	case CharacterRestDataSchemaCharacterSkinWomen2:
		*s = CharacterRestDataSchemaCharacterSkinWomen2
	case CharacterRestDataSchemaCharacterSkinWomen3:
		*s = CharacterRestDataSchemaCharacterSkinWomen3
	default:
		*s = CharacterRestDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterRestDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterRestDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterRestDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterRestDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfCharacterRestDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes CharacterRestDataSchemaCooldown from json.
func (s *CharacterRestDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterRestDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterRestDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterRestDataSchemaCooldown) {
					name = jsonFieldsNameOfCharacterRestDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterRestDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterRestDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterRestDataSchemaCooldownReason as json.
func (s CharacterRestDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterRestDataSchemaCooldownReason from json.
func (s *CharacterRestDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterRestDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterRestDataSchemaCooldownReason(v) {
	case CharacterRestDataSchemaCooldownReasonMovement:
		*s = CharacterRestDataSchemaCooldownReasonMovement
	case CharacterRestDataSchemaCooldownReasonFight:
		*s = CharacterRestDataSchemaCooldownReasonFight
	case CharacterRestDataSchemaCooldownReasonCrafting:
		*s = CharacterRestDataSchemaCooldownReasonCrafting
	case CharacterRestDataSchemaCooldownReasonGathering:
		*s = CharacterRestDataSchemaCooldownReasonGathering
	case CharacterRestDataSchemaCooldownReasonBuyGe:
		*s = CharacterRestDataSchemaCooldownReasonBuyGe
	case CharacterRestDataSchemaCooldownReasonSellGe:
		*s = CharacterRestDataSchemaCooldownReasonSellGe
	case CharacterRestDataSchemaCooldownReasonCancelGe:
		*s = CharacterRestDataSchemaCooldownReasonCancelGe
	case CharacterRestDataSchemaCooldownReasonDeleteItem:
		*s = CharacterRestDataSchemaCooldownReasonDeleteItem
	case CharacterRestDataSchemaCooldownReasonDeposit:
		*s = CharacterRestDataSchemaCooldownReasonDeposit
	case CharacterRestDataSchemaCooldownReasonWithdraw:
		*s = CharacterRestDataSchemaCooldownReasonWithdraw
	case CharacterRestDataSchemaCooldownReasonDepositGold:
		*s = CharacterRestDataSchemaCooldownReasonDepositGold
	case CharacterRestDataSchemaCooldownReasonWithdrawGold:
		*s = CharacterRestDataSchemaCooldownReasonWithdrawGold
	case CharacterRestDataSchemaCooldownReasonEquip:
		*s = CharacterRestDataSchemaCooldownReasonEquip
	case CharacterRestDataSchemaCooldownReasonUnequip:
		*s = CharacterRestDataSchemaCooldownReasonUnequip
	case CharacterRestDataSchemaCooldownReasonTask:
		*s = CharacterRestDataSchemaCooldownReasonTask
	case CharacterRestDataSchemaCooldownReasonRecycling:
		*s = CharacterRestDataSchemaCooldownReasonRecycling
	case CharacterRestDataSchemaCooldownReasonRest:
		*s = CharacterRestDataSchemaCooldownReasonRest
	case CharacterRestDataSchemaCooldownReasonUse:
		*s = CharacterRestDataSchemaCooldownReasonUse
	case CharacterRestDataSchemaCooldownReasonBuyBankExpansion:
		*s = CharacterRestDataSchemaCooldownReasonBuyBankExpansion
	default:
		*s = CharacterRestDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterRestDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterRestDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterRestResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterRestResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCharacterRestResponseSchema = [1]string{
	0: "data",
}

// Decode decodes CharacterRestResponseSchema from json.
func (s *CharacterRestResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterRestResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterRestResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterRestResponseSchema) {
					name = jsonFieldsNameOfCharacterRestResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterRestResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterRestResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCharacterSchema = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes CharacterSchema from json.
func (s *CharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterSchema to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterSchema) {
					name = jsonFieldsNameOfCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterSchemaSkin as json.
func (s CharacterSchemaSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterSchemaSkin from json.
func (s *CharacterSchemaSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterSchemaSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterSchemaSkin(v) {
	case CharacterSchemaSkinMen1:
		*s = CharacterSchemaSkinMen1
	case CharacterSchemaSkinMen2:
		*s = CharacterSchemaSkinMen2
	case CharacterSchemaSkinMen3:
		*s = CharacterSchemaSkinMen3
	case CharacterSchemaSkinWomen1:
		*s = CharacterSchemaSkinWomen1
	case CharacterSchemaSkinWomen2:
		*s = CharacterSchemaSkinWomen2
	case CharacterSchemaSkinWomen3:
		*s = CharacterSchemaSkinWomen3
	default:
		*s = CharacterSchemaSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterSchemaSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterSchemaSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CraftSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CraftSchema) encodeFields(e *jx.Encoder) {
	{
		if s.Skill.Set {
			e.FieldStart("skill")
			s.Skill.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfCraftSchema = [4]string{
	0: "skill",
	1: "level",
	2: "items",
	3: "quantity",
}

// Decode decodes CraftSchema from json.
func (s *CraftSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "skill":
			if err := func() error {
				s.Skill.Reset()
				if err := s.Skill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CraftSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CraftSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaSkill as json.
func (s CraftSchemaSkill) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CraftSchemaSkill from json.
func (s *CraftSchemaSkill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftSchemaSkill to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CraftSchemaSkill(v) {
	case CraftSchemaSkillWeaponcrafting:
		*s = CraftSchemaSkillWeaponcrafting
	case CraftSchemaSkillGearcrafting:
		*s = CraftSchemaSkillGearcrafting
	case CraftSchemaSkillJewelrycrafting:
		*s = CraftSchemaSkillJewelrycrafting
	case CraftSchemaSkillCooking:
		*s = CraftSchemaSkillCooking
	case CraftSchemaSkillWoodcutting:
		*s = CraftSchemaSkillWoodcutting
	case CraftSchemaSkillMining:
		*s = CraftSchemaSkillMining
	case CraftSchemaSkillAlchemy:
		*s = CraftSchemaSkillAlchemy
	default:
		*s = CraftSchemaSkill(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CraftSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CraftingSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CraftingSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfCraftingSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes CraftingSchema from json.
func (s *CraftingSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CraftingSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CraftingSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCraftingSchema) {
					name = jsonFieldsNameOfCraftingSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CraftingSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CraftingSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageAccountAchievementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageAccountAchievementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageAccountAchievementSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageAccountAchievementSchema from json.
func (s *DataPageAccountAchievementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountAchievementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]AccountAchievementSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccountAchievementSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageAccountAchievementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageAccountAchievementSchema) {
					name = jsonFieldsNameOfDataPageAccountAchievementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageAccountAchievementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountAchievementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountAchievementSchemaPage as json.
func (s DataPageAccountAchievementSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAccountAchievementSchemaPage:
		e.Int(s.Int)
	case NullDataPageAccountAchievementSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAccountAchievementSchemaPage from json.
func (s *DataPageAccountAchievementSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountAchievementSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAccountAchievementSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAccountAchievementSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAccountAchievementSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountAchievementSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountAchievementSchemaPages as json.
func (s DataPageAccountAchievementSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAccountAchievementSchemaPages:
		e.Int(s.Int)
	case NullDataPageAccountAchievementSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAccountAchievementSchemaPages from json.
func (s *DataPageAccountAchievementSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountAchievementSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAccountAchievementSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAccountAchievementSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAccountAchievementSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountAchievementSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountAchievementSchemaSize as json.
func (s DataPageAccountAchievementSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAccountAchievementSchemaSize:
		e.Int(s.Int)
	case NullDataPageAccountAchievementSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAccountAchievementSchemaSize from json.
func (s *DataPageAccountAchievementSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountAchievementSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAccountAchievementSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAccountAchievementSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAccountAchievementSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountAchievementSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountAchievementSchemaTotal as json.
func (s DataPageAccountAchievementSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAccountAchievementSchemaTotal:
		e.Int(s.Int)
	case NullDataPageAccountAchievementSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAccountAchievementSchemaTotal from json.
func (s *DataPageAccountAchievementSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountAchievementSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAccountAchievementSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAccountAchievementSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAccountAchievementSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountAchievementSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageAccountLeaderboardSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageAccountLeaderboardSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageAccountLeaderboardSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageAccountLeaderboardSchema from json.
func (s *DataPageAccountLeaderboardSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountLeaderboardSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]AccountLeaderboardSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccountLeaderboardSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageAccountLeaderboardSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageAccountLeaderboardSchema) {
					name = jsonFieldsNameOfDataPageAccountLeaderboardSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageAccountLeaderboardSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountLeaderboardSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountLeaderboardSchemaPage as json.
func (s DataPageAccountLeaderboardSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAccountLeaderboardSchemaPage:
		e.Int(s.Int)
	case NullDataPageAccountLeaderboardSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAccountLeaderboardSchemaPage from json.
func (s *DataPageAccountLeaderboardSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountLeaderboardSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAccountLeaderboardSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAccountLeaderboardSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAccountLeaderboardSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountLeaderboardSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountLeaderboardSchemaPages as json.
func (s DataPageAccountLeaderboardSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAccountLeaderboardSchemaPages:
		e.Int(s.Int)
	case NullDataPageAccountLeaderboardSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAccountLeaderboardSchemaPages from json.
func (s *DataPageAccountLeaderboardSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountLeaderboardSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAccountLeaderboardSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAccountLeaderboardSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAccountLeaderboardSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountLeaderboardSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountLeaderboardSchemaSize as json.
func (s DataPageAccountLeaderboardSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAccountLeaderboardSchemaSize:
		e.Int(s.Int)
	case NullDataPageAccountLeaderboardSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAccountLeaderboardSchemaSize from json.
func (s *DataPageAccountLeaderboardSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountLeaderboardSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAccountLeaderboardSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAccountLeaderboardSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAccountLeaderboardSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountLeaderboardSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountLeaderboardSchemaTotal as json.
func (s DataPageAccountLeaderboardSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAccountLeaderboardSchemaTotal:
		e.Int(s.Int)
	case NullDataPageAccountLeaderboardSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAccountLeaderboardSchemaTotal from json.
func (s *DataPageAccountLeaderboardSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAccountLeaderboardSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAccountLeaderboardSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAccountLeaderboardSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAccountLeaderboardSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAccountLeaderboardSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageAchievementSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageAchievementSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageAchievementSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageAchievementSchema from json.
func (s *DataPageAchievementSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]AchievementSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AchievementSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageAchievementSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageAchievementSchema) {
					name = jsonFieldsNameOfDataPageAchievementSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageAchievementSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaPage as json.
func (s DataPageAchievementSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAchievementSchemaPage:
		e.Int(s.Int)
	case NullDataPageAchievementSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAchievementSchemaPage from json.
func (s *DataPageAchievementSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAchievementSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAchievementSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAchievementSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaPages as json.
func (s DataPageAchievementSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAchievementSchemaPages:
		e.Int(s.Int)
	case NullDataPageAchievementSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAchievementSchemaPages from json.
func (s *DataPageAchievementSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAchievementSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAchievementSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAchievementSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaSize as json.
func (s DataPageAchievementSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAchievementSchemaSize:
		e.Int(s.Int)
	case NullDataPageAchievementSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAchievementSchemaSize from json.
func (s *DataPageAchievementSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAchievementSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAchievementSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAchievementSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaTotal as json.
func (s DataPageAchievementSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageAchievementSchemaTotal:
		e.Int(s.Int)
	case NullDataPageAchievementSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageAchievementSchemaTotal from json.
func (s *DataPageAchievementSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageAchievementSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageAchievementSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageAchievementSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageAchievementSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageAchievementSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageActiveEventSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageActiveEventSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageActiveEventSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageActiveEventSchema from json.
func (s *DataPageActiveEventSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ActiveEventSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActiveEventSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageActiveEventSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageActiveEventSchema) {
					name = jsonFieldsNameOfDataPageActiveEventSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageActiveEventSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaPage as json.
func (s DataPageActiveEventSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageActiveEventSchemaPage:
		e.Int(s.Int)
	case NullDataPageActiveEventSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageActiveEventSchemaPage from json.
func (s *DataPageActiveEventSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageActiveEventSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageActiveEventSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageActiveEventSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaPages as json.
func (s DataPageActiveEventSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageActiveEventSchemaPages:
		e.Int(s.Int)
	case NullDataPageActiveEventSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageActiveEventSchemaPages from json.
func (s *DataPageActiveEventSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageActiveEventSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageActiveEventSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageActiveEventSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaSize as json.
func (s DataPageActiveEventSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageActiveEventSchemaSize:
		e.Int(s.Int)
	case NullDataPageActiveEventSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageActiveEventSchemaSize from json.
func (s *DataPageActiveEventSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageActiveEventSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageActiveEventSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageActiveEventSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaTotal as json.
func (s DataPageActiveEventSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageActiveEventSchemaTotal:
		e.Int(s.Int)
	case NullDataPageActiveEventSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageActiveEventSchemaTotal from json.
func (s *DataPageActiveEventSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageActiveEventSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageActiveEventSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageActiveEventSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageActiveEventSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageActiveEventSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageCharacterLeaderboardSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageCharacterLeaderboardSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageCharacterLeaderboardSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageCharacterLeaderboardSchema from json.
func (s *DataPageCharacterLeaderboardSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CharacterLeaderboardSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterLeaderboardSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageCharacterLeaderboardSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageCharacterLeaderboardSchema) {
					name = jsonFieldsNameOfDataPageCharacterLeaderboardSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageCharacterLeaderboardSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaPage as json.
func (s DataPageCharacterLeaderboardSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaPage:
		e.Int(s.Int)
	case NullDataPageCharacterLeaderboardSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterLeaderboardSchemaPage from json.
func (s *DataPageCharacterLeaderboardSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterLeaderboardSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterLeaderboardSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterLeaderboardSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaPages as json.
func (s DataPageCharacterLeaderboardSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaPages:
		e.Int(s.Int)
	case NullDataPageCharacterLeaderboardSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterLeaderboardSchemaPages from json.
func (s *DataPageCharacterLeaderboardSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterLeaderboardSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterLeaderboardSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterLeaderboardSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaSize as json.
func (s DataPageCharacterLeaderboardSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaSize:
		e.Int(s.Int)
	case NullDataPageCharacterLeaderboardSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterLeaderboardSchemaSize from json.
func (s *DataPageCharacterLeaderboardSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterLeaderboardSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterLeaderboardSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterLeaderboardSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaTotal as json.
func (s DataPageCharacterLeaderboardSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageCharacterLeaderboardSchemaTotal:
		e.Int(s.Int)
	case NullDataPageCharacterLeaderboardSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageCharacterLeaderboardSchemaTotal from json.
func (s *DataPageCharacterLeaderboardSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageCharacterLeaderboardSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageCharacterLeaderboardSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageCharacterLeaderboardSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageCharacterLeaderboardSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageCharacterLeaderboardSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageDropRateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageDropRateSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageDropRateSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageDropRateSchema from json.
func (s *DataPageDropRateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageDropRateSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]DropRateSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropRateSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageDropRateSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageDropRateSchema) {
					name = jsonFieldsNameOfDataPageDropRateSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageDropRateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageDropRateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageDropRateSchemaPage as json.
func (s DataPageDropRateSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageDropRateSchemaPage:
		e.Int(s.Int)
	case NullDataPageDropRateSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageDropRateSchemaPage from json.
func (s *DataPageDropRateSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageDropRateSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageDropRateSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageDropRateSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageDropRateSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageDropRateSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageDropRateSchemaPages as json.
func (s DataPageDropRateSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageDropRateSchemaPages:
		e.Int(s.Int)
	case NullDataPageDropRateSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageDropRateSchemaPages from json.
func (s *DataPageDropRateSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageDropRateSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageDropRateSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageDropRateSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageDropRateSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageDropRateSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageDropRateSchemaSize as json.
func (s DataPageDropRateSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageDropRateSchemaSize:
		e.Int(s.Int)
	case NullDataPageDropRateSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageDropRateSchemaSize from json.
func (s *DataPageDropRateSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageDropRateSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageDropRateSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageDropRateSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageDropRateSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageDropRateSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageDropRateSchemaTotal as json.
func (s DataPageDropRateSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageDropRateSchemaTotal:
		e.Int(s.Int)
	case NullDataPageDropRateSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageDropRateSchemaTotal from json.
func (s *DataPageDropRateSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageDropRateSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageDropRateSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageDropRateSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageDropRateSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageDropRateSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageEventSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageEventSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageEventSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageEventSchema from json.
func (s *DataPageEventSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]EventSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageEventSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageEventSchema) {
					name = jsonFieldsNameOfDataPageEventSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageEventSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaPage as json.
func (s DataPageEventSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageEventSchemaPage:
		e.Int(s.Int)
	case NullDataPageEventSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageEventSchemaPage from json.
func (s *DataPageEventSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageEventSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageEventSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageEventSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaPages as json.
func (s DataPageEventSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageEventSchemaPages:
		e.Int(s.Int)
	case NullDataPageEventSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageEventSchemaPages from json.
func (s *DataPageEventSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageEventSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageEventSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageEventSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaSize as json.
func (s DataPageEventSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageEventSchemaSize:
		e.Int(s.Int)
	case NullDataPageEventSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageEventSchemaSize from json.
func (s *DataPageEventSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageEventSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageEventSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageEventSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaTotal as json.
func (s DataPageEventSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageEventSchemaTotal:
		e.Int(s.Int)
	case NullDataPageEventSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageEventSchemaTotal from json.
func (s *DataPageEventSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageEventSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageEventSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageEventSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageEventSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageEventSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageGEOrderSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageGEOrderSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageGEOrderSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageGEOrderSchema from json.
func (s *DataPageGEOrderSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEOrderSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]GEOrderSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GEOrderSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageGEOrderSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageGEOrderSchema) {
					name = jsonFieldsNameOfDataPageGEOrderSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageGEOrderSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEOrderSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEOrderSchemaPage as json.
func (s DataPageGEOrderSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEOrderSchemaPage:
		e.Int(s.Int)
	case NullDataPageGEOrderSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEOrderSchemaPage from json.
func (s *DataPageGEOrderSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEOrderSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEOrderSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEOrderSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEOrderSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEOrderSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEOrderSchemaPages as json.
func (s DataPageGEOrderSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEOrderSchemaPages:
		e.Int(s.Int)
	case NullDataPageGEOrderSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEOrderSchemaPages from json.
func (s *DataPageGEOrderSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEOrderSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEOrderSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEOrderSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEOrderSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEOrderSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEOrderSchemaSize as json.
func (s DataPageGEOrderSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEOrderSchemaSize:
		e.Int(s.Int)
	case NullDataPageGEOrderSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEOrderSchemaSize from json.
func (s *DataPageGEOrderSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEOrderSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEOrderSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEOrderSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEOrderSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEOrderSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEOrderSchemaTotal as json.
func (s DataPageGEOrderSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGEOrderSchemaTotal:
		e.Int(s.Int)
	case NullDataPageGEOrderSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGEOrderSchemaTotal from json.
func (s *DataPageGEOrderSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGEOrderSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGEOrderSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGEOrderSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGEOrderSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGEOrderSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageGeOrderHistorySchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageGeOrderHistorySchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageGeOrderHistorySchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageGeOrderHistorySchema from json.
func (s *DataPageGeOrderHistorySchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGeOrderHistorySchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]GeOrderHistorySchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GeOrderHistorySchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageGeOrderHistorySchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageGeOrderHistorySchema) {
					name = jsonFieldsNameOfDataPageGeOrderHistorySchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageGeOrderHistorySchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGeOrderHistorySchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGeOrderHistorySchemaPage as json.
func (s DataPageGeOrderHistorySchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGeOrderHistorySchemaPage:
		e.Int(s.Int)
	case NullDataPageGeOrderHistorySchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGeOrderHistorySchemaPage from json.
func (s *DataPageGeOrderHistorySchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGeOrderHistorySchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGeOrderHistorySchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGeOrderHistorySchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGeOrderHistorySchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGeOrderHistorySchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGeOrderHistorySchemaPages as json.
func (s DataPageGeOrderHistorySchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGeOrderHistorySchemaPages:
		e.Int(s.Int)
	case NullDataPageGeOrderHistorySchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGeOrderHistorySchemaPages from json.
func (s *DataPageGeOrderHistorySchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGeOrderHistorySchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGeOrderHistorySchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGeOrderHistorySchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGeOrderHistorySchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGeOrderHistorySchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGeOrderHistorySchemaSize as json.
func (s DataPageGeOrderHistorySchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGeOrderHistorySchemaSize:
		e.Int(s.Int)
	case NullDataPageGeOrderHistorySchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGeOrderHistorySchemaSize from json.
func (s *DataPageGeOrderHistorySchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGeOrderHistorySchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGeOrderHistorySchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGeOrderHistorySchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGeOrderHistorySchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGeOrderHistorySchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGeOrderHistorySchemaTotal as json.
func (s DataPageGeOrderHistorySchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageGeOrderHistorySchemaTotal:
		e.Int(s.Int)
	case NullDataPageGeOrderHistorySchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageGeOrderHistorySchemaTotal from json.
func (s *DataPageGeOrderHistorySchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageGeOrderHistorySchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageGeOrderHistorySchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageGeOrderHistorySchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageGeOrderHistorySchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageGeOrderHistorySchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageItemSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageItemSchema from json.
func (s *DataPageItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageItemSchema) {
					name = jsonFieldsNameOfDataPageItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPage as json.
func (s DataPageItemSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaPage:
		e.Int(s.Int)
	case NullDataPageItemSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaPage from json.
func (s *DataPageItemSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPages as json.
func (s DataPageItemSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaPages:
		e.Int(s.Int)
	case NullDataPageItemSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaPages from json.
func (s *DataPageItemSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaSize as json.
func (s DataPageItemSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaSize:
		e.Int(s.Int)
	case NullDataPageItemSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaSize from json.
func (s *DataPageItemSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaTotal as json.
func (s DataPageItemSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageItemSchemaTotal:
		e.Int(s.Int)
	case NullDataPageItemSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageItemSchemaTotal from json.
func (s *DataPageItemSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageItemSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageItemSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageItemSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageItemSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageItemSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageLogSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageLogSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageLogSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageLogSchema from json.
func (s *DataPageLogSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]LogSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LogSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageLogSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageLogSchema) {
					name = jsonFieldsNameOfDataPageLogSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageLogSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPage as json.
func (s DataPageLogSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaPage:
		e.Int(s.Int)
	case NullDataPageLogSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaPage from json.
func (s *DataPageLogSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPages as json.
func (s DataPageLogSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaPages:
		e.Int(s.Int)
	case NullDataPageLogSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaPages from json.
func (s *DataPageLogSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaSize as json.
func (s DataPageLogSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaSize:
		e.Int(s.Int)
	case NullDataPageLogSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaSize from json.
func (s *DataPageLogSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaTotal as json.
func (s DataPageLogSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageLogSchemaTotal:
		e.Int(s.Int)
	case NullDataPageLogSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageLogSchemaTotal from json.
func (s *DataPageLogSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageLogSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageLogSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageLogSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageLogSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageLogSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageMapSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageMapSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageMapSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageMapSchema from json.
func (s *DataPageMapSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]MapSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MapSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageMapSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageMapSchema) {
					name = jsonFieldsNameOfDataPageMapSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageMapSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPage as json.
func (s DataPageMapSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaPage:
		e.Int(s.Int)
	case NullDataPageMapSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaPage from json.
func (s *DataPageMapSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPages as json.
func (s DataPageMapSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaPages:
		e.Int(s.Int)
	case NullDataPageMapSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaPages from json.
func (s *DataPageMapSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaSize as json.
func (s DataPageMapSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaSize:
		e.Int(s.Int)
	case NullDataPageMapSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaSize from json.
func (s *DataPageMapSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaTotal as json.
func (s DataPageMapSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMapSchemaTotal:
		e.Int(s.Int)
	case NullDataPageMapSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMapSchemaTotal from json.
func (s *DataPageMapSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMapSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMapSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMapSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMapSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMapSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageMonsterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageMonsterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageMonsterSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageMonsterSchema from json.
func (s *DataPageMonsterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]MonsterSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MonsterSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageMonsterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageMonsterSchema) {
					name = jsonFieldsNameOfDataPageMonsterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageMonsterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPage as json.
func (s DataPageMonsterSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaPage:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaPage from json.
func (s *DataPageMonsterSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPages as json.
func (s DataPageMonsterSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaPages:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaPages from json.
func (s *DataPageMonsterSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaSize as json.
func (s DataPageMonsterSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaSize:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaSize from json.
func (s *DataPageMonsterSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaTotal as json.
func (s DataPageMonsterSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageMonsterSchemaTotal:
		e.Int(s.Int)
	case NullDataPageMonsterSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageMonsterSchemaTotal from json.
func (s *DataPageMonsterSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageMonsterSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageMonsterSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageMonsterSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageMonsterSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageMonsterSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageResourceSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageResourceSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageResourceSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageResourceSchema from json.
func (s *DataPageResourceSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ResourceSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResourceSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageResourceSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageResourceSchema) {
					name = jsonFieldsNameOfDataPageResourceSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageResourceSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPage as json.
func (s DataPageResourceSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaPage:
		e.Int(s.Int)
	case NullDataPageResourceSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaPage from json.
func (s *DataPageResourceSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPages as json.
func (s DataPageResourceSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaPages:
		e.Int(s.Int)
	case NullDataPageResourceSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaPages from json.
func (s *DataPageResourceSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaSize as json.
func (s DataPageResourceSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaSize:
		e.Int(s.Int)
	case NullDataPageResourceSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaSize from json.
func (s *DataPageResourceSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaTotal as json.
func (s DataPageResourceSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageResourceSchemaTotal:
		e.Int(s.Int)
	case NullDataPageResourceSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageResourceSchemaTotal from json.
func (s *DataPageResourceSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageResourceSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageResourceSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageResourceSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageResourceSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageResourceSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageSimpleItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageSimpleItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageSimpleItemSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageSimpleItemSchema from json.
func (s *DataPageSimpleItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageSimpleItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageSimpleItemSchema) {
					name = jsonFieldsNameOfDataPageSimpleItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageSimpleItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPage as json.
func (s DataPageSimpleItemSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPage:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaPage from json.
func (s *DataPageSimpleItemSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPages as json.
func (s DataPageSimpleItemSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaPages:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaPages from json.
func (s *DataPageSimpleItemSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaSize as json.
func (s DataPageSimpleItemSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaSize:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaSize from json.
func (s *DataPageSimpleItemSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaTotal as json.
func (s DataPageSimpleItemSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageSimpleItemSchemaTotal:
		e.Int(s.Int)
	case NullDataPageSimpleItemSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageSimpleItemSchemaTotal from json.
func (s *DataPageSimpleItemSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageSimpleItemSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageSimpleItemSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageSimpleItemSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageSimpleItemSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageSimpleItemSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPageTaskFullSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPageTaskFullSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	{
		e.FieldStart("page")
		s.Page.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		if s.Pages.Set {
			e.FieldStart("pages")
			s.Pages.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPageTaskFullSchema = [5]string{
	0: "data",
	1: "total",
	2: "page",
	3: "size",
	4: "pages",
}

// Decode decodes DataPageTaskFullSchema from json.
func (s *DataPageTaskFullSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]TaskFullSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TaskFullSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "page":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPageTaskFullSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPageTaskFullSchema) {
					name = jsonFieldsNameOfDataPageTaskFullSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPageTaskFullSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaPage as json.
func (s DataPageTaskFullSchemaPage) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTaskFullSchemaPage:
		e.Int(s.Int)
	case NullDataPageTaskFullSchemaPage:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTaskFullSchemaPage from json.
func (s *DataPageTaskFullSchemaPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchemaPage to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTaskFullSchemaPage
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTaskFullSchemaPage
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTaskFullSchemaPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchemaPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaPages as json.
func (s DataPageTaskFullSchemaPages) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTaskFullSchemaPages:
		e.Int(s.Int)
	case NullDataPageTaskFullSchemaPages:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTaskFullSchemaPages from json.
func (s *DataPageTaskFullSchemaPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchemaPages to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTaskFullSchemaPages
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTaskFullSchemaPages
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTaskFullSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaSize as json.
func (s DataPageTaskFullSchemaSize) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTaskFullSchemaSize:
		e.Int(s.Int)
	case NullDataPageTaskFullSchemaSize:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTaskFullSchemaSize from json.
func (s *DataPageTaskFullSchemaSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchemaSize to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTaskFullSchemaSize
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTaskFullSchemaSize
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTaskFullSchemaSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchemaSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaTotal as json.
func (s DataPageTaskFullSchemaTotal) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntDataPageTaskFullSchemaTotal:
		e.Int(s.Int)
	case NullDataPageTaskFullSchemaTotal:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes DataPageTaskFullSchemaTotal from json.
func (s *DataPageTaskFullSchemaTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPageTaskFullSchemaTotal to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullDataPageTaskFullSchemaTotal
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntDataPageTaskFullSchemaTotal
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DataPageTaskFullSchemaTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPageTaskFullSchemaTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteCharacterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteCharacterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDeleteCharacterSchema = [1]string{
	0: "name",
}

// Decode decodes DeleteCharacterSchema from json.
func (s *DeleteCharacterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCharacterSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteCharacterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteCharacterSchema) {
					name = jsonFieldsNameOfDeleteCharacterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCharacterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCharacterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes DeleteItemResponseSchema from json.
func (s *DeleteItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemResponseSchema) {
					name = jsonFieldsNameOfDeleteItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemSchema = [3]string{
	0: "cooldown",
	1: "item",
	2: "character",
}

// Decode decodes DeleteItemSchema from json.
func (s *DeleteItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchema) {
					name = jsonFieldsNameOfDeleteItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDeleteItemSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes DeleteItemSchemaCharacter from json.
func (s *DeleteItemSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaCharacter) {
					name = jsonFieldsNameOfDeleteItemSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteItemSchemaCharacterSkin as json.
func (s DeleteItemSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteItemSchemaCharacterSkin from json.
func (s *DeleteItemSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteItemSchemaCharacterSkin(v) {
	case DeleteItemSchemaCharacterSkinMen1:
		*s = DeleteItemSchemaCharacterSkinMen1
	case DeleteItemSchemaCharacterSkinMen2:
		*s = DeleteItemSchemaCharacterSkinMen2
	case DeleteItemSchemaCharacterSkinMen3:
		*s = DeleteItemSchemaCharacterSkinMen3
	case DeleteItemSchemaCharacterSkinWomen1:
		*s = DeleteItemSchemaCharacterSkinWomen1
	case DeleteItemSchemaCharacterSkinWomen2:
		*s = DeleteItemSchemaCharacterSkinWomen2
	case DeleteItemSchemaCharacterSkinWomen3:
		*s = DeleteItemSchemaCharacterSkinWomen3
	default:
		*s = DeleteItemSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteItemSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfDeleteItemSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes DeleteItemSchemaCooldown from json.
func (s *DeleteItemSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaCooldown) {
					name = jsonFieldsNameOfDeleteItemSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteItemSchemaCooldownReason as json.
func (s DeleteItemSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeleteItemSchemaCooldownReason from json.
func (s *DeleteItemSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeleteItemSchemaCooldownReason(v) {
	case DeleteItemSchemaCooldownReasonMovement:
		*s = DeleteItemSchemaCooldownReasonMovement
	case DeleteItemSchemaCooldownReasonFight:
		*s = DeleteItemSchemaCooldownReasonFight
	case DeleteItemSchemaCooldownReasonCrafting:
		*s = DeleteItemSchemaCooldownReasonCrafting
	case DeleteItemSchemaCooldownReasonGathering:
		*s = DeleteItemSchemaCooldownReasonGathering
	case DeleteItemSchemaCooldownReasonBuyGe:
		*s = DeleteItemSchemaCooldownReasonBuyGe
	case DeleteItemSchemaCooldownReasonSellGe:
		*s = DeleteItemSchemaCooldownReasonSellGe
	case DeleteItemSchemaCooldownReasonCancelGe:
		*s = DeleteItemSchemaCooldownReasonCancelGe
	case DeleteItemSchemaCooldownReasonDeleteItem:
		*s = DeleteItemSchemaCooldownReasonDeleteItem
	case DeleteItemSchemaCooldownReasonDeposit:
		*s = DeleteItemSchemaCooldownReasonDeposit
	case DeleteItemSchemaCooldownReasonWithdraw:
		*s = DeleteItemSchemaCooldownReasonWithdraw
	case DeleteItemSchemaCooldownReasonDepositGold:
		*s = DeleteItemSchemaCooldownReasonDepositGold
	case DeleteItemSchemaCooldownReasonWithdrawGold:
		*s = DeleteItemSchemaCooldownReasonWithdrawGold
	case DeleteItemSchemaCooldownReasonEquip:
		*s = DeleteItemSchemaCooldownReasonEquip
	case DeleteItemSchemaCooldownReasonUnequip:
		*s = DeleteItemSchemaCooldownReasonUnequip
	case DeleteItemSchemaCooldownReasonTask:
		*s = DeleteItemSchemaCooldownReasonTask
	case DeleteItemSchemaCooldownReasonRecycling:
		*s = DeleteItemSchemaCooldownReasonRecycling
	case DeleteItemSchemaCooldownReasonRest:
		*s = DeleteItemSchemaCooldownReasonRest
	case DeleteItemSchemaCooldownReasonUse:
		*s = DeleteItemSchemaCooldownReasonUse
	case DeleteItemSchemaCooldownReasonBuyBankExpansion:
		*s = DeleteItemSchemaCooldownReasonBuyBankExpansion
	default:
		*s = DeleteItemSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteItemSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteItemSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteItemSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDeleteItemSchemaItem = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes DeleteItemSchemaItem from json.
func (s *DeleteItemSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteItemSchemaItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteItemSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteItemSchemaItem) {
					name = jsonFieldsNameOfDeleteItemSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteItemSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteItemSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepositWithdrawGoldSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepositWithdrawGoldSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDepositWithdrawGoldSchema = [1]string{
	0: "quantity",
}

// Decode decodes DepositWithdrawGoldSchema from json.
func (s *DepositWithdrawGoldSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositWithdrawGoldSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quantity":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepositWithdrawGoldSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDepositWithdrawGoldSchema) {
					name = jsonFieldsNameOfDepositWithdrawGoldSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepositWithdrawGoldSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositWithdrawGoldSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DestinationSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DestinationSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfDestinationSchema = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes DestinationSchema from json.
func (s *DestinationSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DestinationSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DestinationSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDestinationSchema) {
					name = jsonFieldsNameOfDestinationSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DestinationSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DestinationSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DropRateSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DropRateSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("rate")
		e.Int(s.Rate)
	}
	{
		e.FieldStart("min_quantity")
		e.Int(s.MinQuantity)
	}
	{
		e.FieldStart("max_quantity")
		e.Int(s.MaxQuantity)
	}
}

var jsonFieldsNameOfDropRateSchema = [4]string{
	0: "code",
	1: "rate",
	2: "min_quantity",
	3: "max_quantity",
}

// Decode decodes DropRateSchema from json.
func (s *DropRateSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DropRateSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "rate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Rate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		case "min_quantity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MinQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_quantity\"")
			}
		case "max_quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.MaxQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DropRateSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDropRateSchema) {
					name = jsonFieldsNameOfDropRateSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DropRateSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DropRateSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DropSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DropSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfDropSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes DropSchema from json.
func (s *DropSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DropSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DropSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDropSchema) {
					name = jsonFieldsNameOfDropSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DropSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DropSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfEquipRequestSchema = [4]string{
	0: "cooldown",
	1: "slot",
	2: "item",
	3: "character",
}

// Decode decodes EquipRequestSchema from json.
func (s *EquipRequestSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "slot":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchema) {
					name = jsonFieldsNameOfEquipRequestSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEquipRequestSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes EquipRequestSchemaCharacter from json.
func (s *EquipRequestSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaCharacter) {
					name = jsonFieldsNameOfEquipRequestSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaCharacterSkin as json.
func (s EquipRequestSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaCharacterSkin from json.
func (s *EquipRequestSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaCharacterSkin(v) {
	case EquipRequestSchemaCharacterSkinMen1:
		*s = EquipRequestSchemaCharacterSkinMen1
	case EquipRequestSchemaCharacterSkinMen2:
		*s = EquipRequestSchemaCharacterSkinMen2
	case EquipRequestSchemaCharacterSkinMen3:
		*s = EquipRequestSchemaCharacterSkinMen3
	case EquipRequestSchemaCharacterSkinWomen1:
		*s = EquipRequestSchemaCharacterSkinWomen1
	case EquipRequestSchemaCharacterSkinWomen2:
		*s = EquipRequestSchemaCharacterSkinWomen2
	case EquipRequestSchemaCharacterSkinWomen3:
		*s = EquipRequestSchemaCharacterSkinWomen3
	default:
		*s = EquipRequestSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfEquipRequestSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes EquipRequestSchemaCooldown from json.
func (s *EquipRequestSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaCooldown) {
					name = jsonFieldsNameOfEquipRequestSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaCooldownReason as json.
func (s EquipRequestSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaCooldownReason from json.
func (s *EquipRequestSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaCooldownReason(v) {
	case EquipRequestSchemaCooldownReasonMovement:
		*s = EquipRequestSchemaCooldownReasonMovement
	case EquipRequestSchemaCooldownReasonFight:
		*s = EquipRequestSchemaCooldownReasonFight
	case EquipRequestSchemaCooldownReasonCrafting:
		*s = EquipRequestSchemaCooldownReasonCrafting
	case EquipRequestSchemaCooldownReasonGathering:
		*s = EquipRequestSchemaCooldownReasonGathering
	case EquipRequestSchemaCooldownReasonBuyGe:
		*s = EquipRequestSchemaCooldownReasonBuyGe
	case EquipRequestSchemaCooldownReasonSellGe:
		*s = EquipRequestSchemaCooldownReasonSellGe
	case EquipRequestSchemaCooldownReasonCancelGe:
		*s = EquipRequestSchemaCooldownReasonCancelGe
	case EquipRequestSchemaCooldownReasonDeleteItem:
		*s = EquipRequestSchemaCooldownReasonDeleteItem
	case EquipRequestSchemaCooldownReasonDeposit:
		*s = EquipRequestSchemaCooldownReasonDeposit
	case EquipRequestSchemaCooldownReasonWithdraw:
		*s = EquipRequestSchemaCooldownReasonWithdraw
	case EquipRequestSchemaCooldownReasonDepositGold:
		*s = EquipRequestSchemaCooldownReasonDepositGold
	case EquipRequestSchemaCooldownReasonWithdrawGold:
		*s = EquipRequestSchemaCooldownReasonWithdrawGold
	case EquipRequestSchemaCooldownReasonEquip:
		*s = EquipRequestSchemaCooldownReasonEquip
	case EquipRequestSchemaCooldownReasonUnequip:
		*s = EquipRequestSchemaCooldownReasonUnequip
	case EquipRequestSchemaCooldownReasonTask:
		*s = EquipRequestSchemaCooldownReasonTask
	case EquipRequestSchemaCooldownReasonRecycling:
		*s = EquipRequestSchemaCooldownReasonRecycling
	case EquipRequestSchemaCooldownReasonRest:
		*s = EquipRequestSchemaCooldownReasonRest
	case EquipRequestSchemaCooldownReasonUse:
		*s = EquipRequestSchemaCooldownReasonUse
	case EquipRequestSchemaCooldownReasonBuyBankExpansion:
		*s = EquipRequestSchemaCooldownReasonBuyBankExpansion
	default:
		*s = EquipRequestSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipRequestSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipRequestSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
	{
		e.FieldStart("tradeable")
		e.Bool(s.Tradeable)
	}
}

var jsonFieldsNameOfEquipRequestSchemaItem = [9]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
	8: "tradeable",
}

// Decode decodes EquipRequestSchemaItem from json.
func (s *EquipRequestSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		case "tradeable":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Tradeable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipRequestSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipRequestSchemaItem) {
					name = jsonFieldsNameOfEquipRequestSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipRequestSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaItemCraft as json.
func (s EquipRequestSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaEquipRequestSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullEquipRequestSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes EquipRequestSchemaItemCraft from json.
func (s *EquipRequestSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullEquipRequestSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaEquipRequestSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipRequestSchemaSlot as json.
func (s EquipRequestSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipRequestSchemaSlot from json.
func (s *EquipRequestSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipRequestSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipRequestSchemaSlot(v) {
	case EquipRequestSchemaSlotWeapon:
		*s = EquipRequestSchemaSlotWeapon
	case EquipRequestSchemaSlotShield:
		*s = EquipRequestSchemaSlotShield
	case EquipRequestSchemaSlotHelmet:
		*s = EquipRequestSchemaSlotHelmet
	case EquipRequestSchemaSlotBodyArmor:
		*s = EquipRequestSchemaSlotBodyArmor
	case EquipRequestSchemaSlotLegArmor:
		*s = EquipRequestSchemaSlotLegArmor
	case EquipRequestSchemaSlotBoots:
		*s = EquipRequestSchemaSlotBoots
	case EquipRequestSchemaSlotRing1:
		*s = EquipRequestSchemaSlotRing1
	case EquipRequestSchemaSlotRing2:
		*s = EquipRequestSchemaSlotRing2
	case EquipRequestSchemaSlotAmulet:
		*s = EquipRequestSchemaSlotAmulet
	case EquipRequestSchemaSlotArtifact1:
		*s = EquipRequestSchemaSlotArtifact1
	case EquipRequestSchemaSlotArtifact2:
		*s = EquipRequestSchemaSlotArtifact2
	case EquipRequestSchemaSlotArtifact3:
		*s = EquipRequestSchemaSlotArtifact3
	case EquipRequestSchemaSlotUtility1:
		*s = EquipRequestSchemaSlotUtility1
	case EquipRequestSchemaSlotUtility2:
		*s = EquipRequestSchemaSlotUtility2
	default:
		*s = EquipRequestSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipRequestSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipRequestSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfEquipSchema = [3]string{
	0: "code",
	1: "slot",
	2: "quantity",
}

// Decode decodes EquipSchema from json.
func (s *EquipSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "slot":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipSchema) {
					name = jsonFieldsNameOfEquipSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EquipSchemaSlot as json.
func (s EquipSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EquipSchemaSlot from json.
func (s *EquipSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EquipSchemaSlot(v) {
	case EquipSchemaSlotWeapon:
		*s = EquipSchemaSlotWeapon
	case EquipSchemaSlotShield:
		*s = EquipSchemaSlotShield
	case EquipSchemaSlotHelmet:
		*s = EquipSchemaSlotHelmet
	case EquipSchemaSlotBodyArmor:
		*s = EquipSchemaSlotBodyArmor
	case EquipSchemaSlotLegArmor:
		*s = EquipSchemaSlotLegArmor
	case EquipSchemaSlotBoots:
		*s = EquipSchemaSlotBoots
	case EquipSchemaSlotRing1:
		*s = EquipSchemaSlotRing1
	case EquipSchemaSlotRing2:
		*s = EquipSchemaSlotRing2
	case EquipSchemaSlotAmulet:
		*s = EquipSchemaSlotAmulet
	case EquipSchemaSlotArtifact1:
		*s = EquipSchemaSlotArtifact1
	case EquipSchemaSlotArtifact2:
		*s = EquipSchemaSlotArtifact2
	case EquipSchemaSlotArtifact3:
		*s = EquipSchemaSlotArtifact3
	case EquipSchemaSlotUtility1:
		*s = EquipSchemaSlotUtility1
	case EquipSchemaSlotUtility2:
		*s = EquipSchemaSlotUtility2
	default:
		*s = EquipSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EquipSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipmentResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipmentResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfEquipmentResponseSchema = [1]string{
	0: "data",
}

// Decode decodes EquipmentResponseSchema from json.
func (s *EquipmentResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipmentResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipmentResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEquipmentResponseSchema) {
					name = jsonFieldsNameOfEquipmentResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipmentResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipmentResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventMapSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventMapSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
}

var jsonFieldsNameOfEventMapSchema = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes EventMapSchema from json.
func (s *EventMapSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventMapSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventMapSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventMapSchema) {
					name = jsonFieldsNameOfEventMapSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventMapSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventMapSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("maps")
		e.ArrStart()
		for _, elem := range s.Maps {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("duration")
		e.Int(s.Duration)
	}
	{
		e.FieldStart("rate")
		e.Int(s.Rate)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfEventSchema = [7]string{
	0: "name",
	1: "code",
	2: "maps",
	3: "skin",
	4: "duration",
	5: "rate",
	6: "content",
}

// Decode decodes EventSchema from json.
func (s *EventSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "maps":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Maps = make([]EventMapSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventMapSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Maps = append(s.Maps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maps\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "rate":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Rate = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventSchema) {
					name = jsonFieldsNameOfEventSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventSchemaContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventSchemaContent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
}

var jsonFieldsNameOfEventSchemaContent = [2]string{
	0: "type",
	1: "code",
}

// Decode decodes EventSchemaContent from json.
func (s *EventSchemaContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventSchemaContent to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventSchemaContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventSchemaContent) {
					name = jsonFieldsNameOfEventSchemaContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventSchemaContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventSchemaContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEBuyOrderSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEBuyOrderSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfGEBuyOrderSchema = [2]string{
	0: "id",
	1: "quantity",
}

// Decode decodes GEBuyOrderSchema from json.
func (s *GEBuyOrderSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEBuyOrderSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEBuyOrderSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEBuyOrderSchema) {
					name = jsonFieldsNameOfGEBuyOrderSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEBuyOrderSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEBuyOrderSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GECancelOrderSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GECancelOrderSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfGECancelOrderSchema = [1]string{
	0: "id",
}

// Decode decodes GECancelOrderSchema from json.
func (s *GECancelOrderSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GECancelOrderSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GECancelOrderSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGECancelOrderSchema) {
					name = jsonFieldsNameOfGECancelOrderSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GECancelOrderSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GECancelOrderSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GECreateOrderTransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GECreateOrderTransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGECreateOrderTransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes GECreateOrderTransactionResponseSchema from json.
func (s *GECreateOrderTransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GECreateOrderTransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GECreateOrderTransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGECreateOrderTransactionResponseSchema) {
					name = jsonFieldsNameOfGECreateOrderTransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GECreateOrderTransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GECreateOrderTransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEOrderCreationrSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEOrderCreationrSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
}

var jsonFieldsNameOfGEOrderCreationrSchema = [3]string{
	0: "code",
	1: "quantity",
	2: "price",
}

// Decode decodes GEOrderCreationrSchema from json.
func (s *GEOrderCreationrSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderCreationrSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEOrderCreationrSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEOrderCreationrSchema) {
					name = jsonFieldsNameOfGEOrderCreationrSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEOrderCreationrSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderCreationrSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEOrderReponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEOrderReponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGEOrderReponseSchema = [1]string{
	0: "data",
}

// Decode decodes GEOrderReponseSchema from json.
func (s *GEOrderReponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderReponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEOrderReponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEOrderReponseSchema) {
					name = jsonFieldsNameOfGEOrderReponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEOrderReponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderReponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEOrderSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEOrderSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("seller")
		e.Str(s.Seller)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfGEOrderSchema = [6]string{
	0: "id",
	1: "seller",
	2: "code",
	3: "quantity",
	4: "price",
	5: "created_at",
}

// Decode decodes GEOrderSchema from json.
func (s *GEOrderSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "seller":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Seller = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seller\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEOrderSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEOrderSchema) {
					name = jsonFieldsNameOfGEOrderSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEOrderSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEOrderTransactionSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEOrderTransactionSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("order")
		s.Order.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfGEOrderTransactionSchema = [3]string{
	0: "cooldown",
	1: "order",
	2: "character",
}

// Decode decodes GEOrderTransactionSchema from json.
func (s *GEOrderTransactionSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderTransactionSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "order":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEOrderTransactionSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEOrderTransactionSchema) {
					name = jsonFieldsNameOfGEOrderTransactionSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEOrderTransactionSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderTransactionSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEOrderTransactionSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEOrderTransactionSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGEOrderTransactionSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes GEOrderTransactionSchemaCharacter from json.
func (s *GEOrderTransactionSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderTransactionSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEOrderTransactionSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEOrderTransactionSchemaCharacter) {
					name = jsonFieldsNameOfGEOrderTransactionSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEOrderTransactionSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderTransactionSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GEOrderTransactionSchemaCharacterSkin as json.
func (s GEOrderTransactionSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GEOrderTransactionSchemaCharacterSkin from json.
func (s *GEOrderTransactionSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderTransactionSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GEOrderTransactionSchemaCharacterSkin(v) {
	case GEOrderTransactionSchemaCharacterSkinMen1:
		*s = GEOrderTransactionSchemaCharacterSkinMen1
	case GEOrderTransactionSchemaCharacterSkinMen2:
		*s = GEOrderTransactionSchemaCharacterSkinMen2
	case GEOrderTransactionSchemaCharacterSkinMen3:
		*s = GEOrderTransactionSchemaCharacterSkinMen3
	case GEOrderTransactionSchemaCharacterSkinWomen1:
		*s = GEOrderTransactionSchemaCharacterSkinWomen1
	case GEOrderTransactionSchemaCharacterSkinWomen2:
		*s = GEOrderTransactionSchemaCharacterSkinWomen2
	case GEOrderTransactionSchemaCharacterSkinWomen3:
		*s = GEOrderTransactionSchemaCharacterSkinWomen3
	default:
		*s = GEOrderTransactionSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GEOrderTransactionSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderTransactionSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEOrderTransactionSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEOrderTransactionSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfGEOrderTransactionSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes GEOrderTransactionSchemaCooldown from json.
func (s *GEOrderTransactionSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderTransactionSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEOrderTransactionSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEOrderTransactionSchemaCooldown) {
					name = jsonFieldsNameOfGEOrderTransactionSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEOrderTransactionSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderTransactionSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GEOrderTransactionSchemaCooldownReason as json.
func (s GEOrderTransactionSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GEOrderTransactionSchemaCooldownReason from json.
func (s *GEOrderTransactionSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderTransactionSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GEOrderTransactionSchemaCooldownReason(v) {
	case GEOrderTransactionSchemaCooldownReasonMovement:
		*s = GEOrderTransactionSchemaCooldownReasonMovement
	case GEOrderTransactionSchemaCooldownReasonFight:
		*s = GEOrderTransactionSchemaCooldownReasonFight
	case GEOrderTransactionSchemaCooldownReasonCrafting:
		*s = GEOrderTransactionSchemaCooldownReasonCrafting
	case GEOrderTransactionSchemaCooldownReasonGathering:
		*s = GEOrderTransactionSchemaCooldownReasonGathering
	case GEOrderTransactionSchemaCooldownReasonBuyGe:
		*s = GEOrderTransactionSchemaCooldownReasonBuyGe
	case GEOrderTransactionSchemaCooldownReasonSellGe:
		*s = GEOrderTransactionSchemaCooldownReasonSellGe
	case GEOrderTransactionSchemaCooldownReasonCancelGe:
		*s = GEOrderTransactionSchemaCooldownReasonCancelGe
	case GEOrderTransactionSchemaCooldownReasonDeleteItem:
		*s = GEOrderTransactionSchemaCooldownReasonDeleteItem
	case GEOrderTransactionSchemaCooldownReasonDeposit:
		*s = GEOrderTransactionSchemaCooldownReasonDeposit
	case GEOrderTransactionSchemaCooldownReasonWithdraw:
		*s = GEOrderTransactionSchemaCooldownReasonWithdraw
	case GEOrderTransactionSchemaCooldownReasonDepositGold:
		*s = GEOrderTransactionSchemaCooldownReasonDepositGold
	case GEOrderTransactionSchemaCooldownReasonWithdrawGold:
		*s = GEOrderTransactionSchemaCooldownReasonWithdrawGold
	case GEOrderTransactionSchemaCooldownReasonEquip:
		*s = GEOrderTransactionSchemaCooldownReasonEquip
	case GEOrderTransactionSchemaCooldownReasonUnequip:
		*s = GEOrderTransactionSchemaCooldownReasonUnequip
	case GEOrderTransactionSchemaCooldownReasonTask:
		*s = GEOrderTransactionSchemaCooldownReasonTask
	case GEOrderTransactionSchemaCooldownReasonRecycling:
		*s = GEOrderTransactionSchemaCooldownReasonRecycling
	case GEOrderTransactionSchemaCooldownReasonRest:
		*s = GEOrderTransactionSchemaCooldownReasonRest
	case GEOrderTransactionSchemaCooldownReasonUse:
		*s = GEOrderTransactionSchemaCooldownReasonUse
	case GEOrderTransactionSchemaCooldownReasonBuyBankExpansion:
		*s = GEOrderTransactionSchemaCooldownReasonBuyBankExpansion
	default:
		*s = GEOrderTransactionSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GEOrderTransactionSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderTransactionSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GEOrderTransactionSchemaOrder) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GEOrderTransactionSchemaOrder) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
	{
		e.FieldStart("total_price")
		e.Int(s.TotalPrice)
	}
	{
		e.FieldStart("tax")
		e.Int(s.Tax)
	}
}

var jsonFieldsNameOfGEOrderTransactionSchemaOrder = [7]string{
	0: "id",
	1: "created_at",
	2: "code",
	3: "quantity",
	4: "price",
	5: "total_price",
	6: "tax",
}

// Decode decodes GEOrderTransactionSchemaOrder from json.
func (s *GEOrderTransactionSchemaOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GEOrderTransactionSchemaOrder to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "total_price":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalPrice = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_price\"")
			}
		case "tax":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Tax = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tax\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GEOrderTransactionSchemaOrder")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGEOrderTransactionSchemaOrder) {
					name = jsonFieldsNameOfGEOrderTransactionSchemaOrder[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GEOrderTransactionSchemaOrder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GEOrderTransactionSchemaOrder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("order")
		s.Order.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionListSchema = [3]string{
	0: "cooldown",
	1: "order",
	2: "character",
}

// Decode decodes GETransactionListSchema from json.
func (s *GETransactionListSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "order":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchema) {
					name = jsonFieldsNameOfGETransactionListSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGETransactionListSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes GETransactionListSchemaCharacter from json.
func (s *GETransactionListSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaCharacter) {
					name = jsonFieldsNameOfGETransactionListSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GETransactionListSchemaCharacterSkin as json.
func (s GETransactionListSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GETransactionListSchemaCharacterSkin from json.
func (s *GETransactionListSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GETransactionListSchemaCharacterSkin(v) {
	case GETransactionListSchemaCharacterSkinMen1:
		*s = GETransactionListSchemaCharacterSkinMen1
	case GETransactionListSchemaCharacterSkinMen2:
		*s = GETransactionListSchemaCharacterSkinMen2
	case GETransactionListSchemaCharacterSkinMen3:
		*s = GETransactionListSchemaCharacterSkinMen3
	case GETransactionListSchemaCharacterSkinWomen1:
		*s = GETransactionListSchemaCharacterSkinWomen1
	case GETransactionListSchemaCharacterSkinWomen2:
		*s = GETransactionListSchemaCharacterSkinWomen2
	case GETransactionListSchemaCharacterSkinWomen3:
		*s = GETransactionListSchemaCharacterSkinWomen3
	default:
		*s = GETransactionListSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GETransactionListSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionListSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes GETransactionListSchemaCooldown from json.
func (s *GETransactionListSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaCooldown) {
					name = jsonFieldsNameOfGETransactionListSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GETransactionListSchemaCooldownReason as json.
func (s GETransactionListSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GETransactionListSchemaCooldownReason from json.
func (s *GETransactionListSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GETransactionListSchemaCooldownReason(v) {
	case GETransactionListSchemaCooldownReasonMovement:
		*s = GETransactionListSchemaCooldownReasonMovement
	case GETransactionListSchemaCooldownReasonFight:
		*s = GETransactionListSchemaCooldownReasonFight
	case GETransactionListSchemaCooldownReasonCrafting:
		*s = GETransactionListSchemaCooldownReasonCrafting
	case GETransactionListSchemaCooldownReasonGathering:
		*s = GETransactionListSchemaCooldownReasonGathering
	case GETransactionListSchemaCooldownReasonBuyGe:
		*s = GETransactionListSchemaCooldownReasonBuyGe
	case GETransactionListSchemaCooldownReasonSellGe:
		*s = GETransactionListSchemaCooldownReasonSellGe
	case GETransactionListSchemaCooldownReasonCancelGe:
		*s = GETransactionListSchemaCooldownReasonCancelGe
	case GETransactionListSchemaCooldownReasonDeleteItem:
		*s = GETransactionListSchemaCooldownReasonDeleteItem
	case GETransactionListSchemaCooldownReasonDeposit:
		*s = GETransactionListSchemaCooldownReasonDeposit
	case GETransactionListSchemaCooldownReasonWithdraw:
		*s = GETransactionListSchemaCooldownReasonWithdraw
	case GETransactionListSchemaCooldownReasonDepositGold:
		*s = GETransactionListSchemaCooldownReasonDepositGold
	case GETransactionListSchemaCooldownReasonWithdrawGold:
		*s = GETransactionListSchemaCooldownReasonWithdrawGold
	case GETransactionListSchemaCooldownReasonEquip:
		*s = GETransactionListSchemaCooldownReasonEquip
	case GETransactionListSchemaCooldownReasonUnequip:
		*s = GETransactionListSchemaCooldownReasonUnequip
	case GETransactionListSchemaCooldownReasonTask:
		*s = GETransactionListSchemaCooldownReasonTask
	case GETransactionListSchemaCooldownReasonRecycling:
		*s = GETransactionListSchemaCooldownReasonRecycling
	case GETransactionListSchemaCooldownReasonRest:
		*s = GETransactionListSchemaCooldownReasonRest
	case GETransactionListSchemaCooldownReasonUse:
		*s = GETransactionListSchemaCooldownReasonUse
	case GETransactionListSchemaCooldownReasonBuyBankExpansion:
		*s = GETransactionListSchemaCooldownReasonBuyBankExpansion
	default:
		*s = GETransactionListSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GETransactionListSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionListSchemaOrder) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionListSchemaOrder) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
	{
		e.FieldStart("total_price")
		e.Int(s.TotalPrice)
	}
}

var jsonFieldsNameOfGETransactionListSchemaOrder = [5]string{
	0: "id",
	1: "code",
	2: "quantity",
	3: "price",
	4: "total_price",
}

// Decode decodes GETransactionListSchemaOrder from json.
func (s *GETransactionListSchemaOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionListSchemaOrder to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "total_price":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TotalPrice = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionListSchemaOrder")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionListSchemaOrder) {
					name = jsonFieldsNameOfGETransactionListSchemaOrder[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionListSchemaOrder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionListSchemaOrder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GETransactionResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GETransactionResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfGETransactionResponseSchema = [1]string{
	0: "data",
}

// Decode decodes GETransactionResponseSchema from json.
func (s *GETransactionResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GETransactionResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GETransactionResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGETransactionResponseSchema) {
					name = jsonFieldsNameOfGETransactionResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GETransactionResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GETransactionResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GeOrderHistorySchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GeOrderHistorySchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("order_id")
		e.Str(s.OrderID)
	}
	{
		e.FieldStart("seller")
		e.Str(s.Seller)
	}
	{
		e.FieldStart("buyer")
		e.Str(s.Buyer)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
	{
		e.FieldStart("price")
		e.Int(s.Price)
	}
	{
		e.FieldStart("sold_at")
		json.EncodeDateTime(e, s.SoldAt)
	}
}

var jsonFieldsNameOfGeOrderHistorySchema = [7]string{
	0: "order_id",
	1: "seller",
	2: "buyer",
	3: "code",
	4: "quantity",
	5: "price",
	6: "sold_at",
}

// Decode decodes GeOrderHistorySchema from json.
func (s *GeOrderHistorySchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GeOrderHistorySchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "order_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OrderID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order_id\"")
			}
		case "seller":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Seller = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seller\"")
			}
		case "buyer":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Buyer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyer\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Price = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "sold_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.SoldAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sold_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GeOrderHistorySchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGeOrderHistorySchema) {
					name = jsonFieldsNameOfGeOrderHistorySchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GeOrderHistorySchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GeOrderHistorySchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InventorySlot) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InventorySlot) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slot")
		e.Int(s.Slot)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfInventorySlot = [3]string{
	0: "slot",
	1: "code",
	2: "quantity",
}

// Decode decodes InventorySlot from json.
func (s *InventorySlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InventorySlot to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slot":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Slot = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InventorySlot")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInventorySlot) {
					name = jsonFieldsNameOfInventorySlot[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InventorySlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InventorySlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemEffectSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemEffectSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Int(s.Value)
	}
}

var jsonFieldsNameOfItemEffectSchema = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes ItemEffectSchema from json.
func (s *ItemEffectSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemEffectSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Value = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemEffectSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemEffectSchema) {
					name = jsonFieldsNameOfItemEffectSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemEffectSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemEffectSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes ItemResponseSchema from json.
func (s *ItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemResponseSchema) {
					name = jsonFieldsNameOfItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
	{
		e.FieldStart("tradeable")
		e.Bool(s.Tradeable)
	}
}

var jsonFieldsNameOfItemSchema = [9]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
	8: "tradeable",
}

// Decode decodes ItemSchema from json.
func (s *ItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		case "tradeable":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Tradeable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfItemSchema) {
					name = jsonFieldsNameOfItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ItemSchemaCraft as json.
func (s ItemSchemaCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaItemSchemaCraft:
		s.CraftSchema.Encode(e)
	case NullItemSchemaCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes ItemSchemaCraft from json.
func (s *ItemSchemaCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemSchemaCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullItemSchemaCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaItemSchemaCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ItemSchemaCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemSchemaCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LogSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LogSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character")
		e.Str(s.Character)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if len(s.Content) != 0 {
			e.FieldStart("content")
			e.Raw(s.Content)
		}
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		e.FieldStart("cooldown_expiration")
		s.CooldownExpiration.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfLogSchema = [8]string{
	0: "character",
	1: "account",
	2: "type",
	3: "description",
	4: "content",
	5: "cooldown",
	6: "cooldown_expiration",
	7: "created_at",
}

// Decode decodes LogSchema from json.
func (s *LogSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Character = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Content = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "cooldown":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.CooldownExpiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LogSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLogSchema) {
					name = jsonFieldsNameOfLogSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LogSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogSchemaCooldownExpiration as json.
func (s LogSchemaCooldownExpiration) Encode(e *jx.Encoder) {
	switch s.Type {
	case DateTimeLogSchemaCooldownExpiration:
		json.EncodeDateTime(e, s.DateTime)
	case NullLogSchemaCooldownExpiration:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes LogSchemaCooldownExpiration from json.
func (s *LogSchemaCooldownExpiration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogSchemaCooldownExpiration to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullLogSchemaCooldownExpiration
	case jx.String:
		v, err := json.DecodeDateTime(d)
		s.DateTime = v
		if err != nil {
			return err
		}
		s.Type = DateTimeLogSchemaCooldownExpiration
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogSchemaCooldownExpiration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogSchemaCooldownExpiration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogSchemaType as json.
func (s LogSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LogSchemaType from json.
func (s *LogSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LogSchemaType(v) {
	case LogSchemaTypeSpawn:
		*s = LogSchemaTypeSpawn
	case LogSchemaTypeMovement:
		*s = LogSchemaTypeMovement
	case LogSchemaTypeFight:
		*s = LogSchemaTypeFight
	case LogSchemaTypeCrafting:
		*s = LogSchemaTypeCrafting
	case LogSchemaTypeGathering:
		*s = LogSchemaTypeGathering
	case LogSchemaTypeBuyGe:
		*s = LogSchemaTypeBuyGe
	case LogSchemaTypeSellGe:
		*s = LogSchemaTypeSellGe
	case LogSchemaTypeCancelGe:
		*s = LogSchemaTypeCancelGe
	case LogSchemaTypeDeleteItem:
		*s = LogSchemaTypeDeleteItem
	case LogSchemaTypeDeposit:
		*s = LogSchemaTypeDeposit
	case LogSchemaTypeWithdraw:
		*s = LogSchemaTypeWithdraw
	case LogSchemaTypeDepositGold:
		*s = LogSchemaTypeDepositGold
	case LogSchemaTypeWithdrawGold:
		*s = LogSchemaTypeWithdrawGold
	case LogSchemaTypeEquip:
		*s = LogSchemaTypeEquip
	case LogSchemaTypeUnequip:
		*s = LogSchemaTypeUnequip
	case LogSchemaTypeNewTask:
		*s = LogSchemaTypeNewTask
	case LogSchemaTypeTaskExchange:
		*s = LogSchemaTypeTaskExchange
	case LogSchemaTypeTaskCancelled:
		*s = LogSchemaTypeTaskCancelled
	case LogSchemaTypeTaskCompleted:
		*s = LogSchemaTypeTaskCompleted
	case LogSchemaTypeTaskTrade:
		*s = LogSchemaTypeTaskTrade
	case LogSchemaTypeRecycling:
		*s = LogSchemaTypeRecycling
	case LogSchemaTypeRest:
		*s = LogSchemaTypeRest
	case LogSchemaTypeUse:
		*s = LogSchemaTypeUse
	case LogSchemaTypeBuyBankExpansion:
		*s = LogSchemaTypeBuyBankExpansion
	case LogSchemaTypeAchievement:
		*s = LogSchemaTypeAchievement
	default:
		*s = LogSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapContentSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapContentSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
}

var jsonFieldsNameOfMapContentSchema = [2]string{
	0: "type",
	1: "code",
}

// Decode decodes MapContentSchema from json.
func (s *MapContentSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapContentSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapContentSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapContentSchema) {
					name = jsonFieldsNameOfMapContentSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapContentSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapContentSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfMapResponseSchema = [1]string{
	0: "data",
}

// Decode decodes MapResponseSchema from json.
func (s *MapResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapResponseSchema) {
					name = jsonFieldsNameOfMapResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MapSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MapSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("skin")
		e.Str(s.Skin)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("content")
		s.Content.Encode(e)
	}
}

var jsonFieldsNameOfMapSchema = [5]string{
	0: "name",
	1: "skin",
	2: "x",
	3: "y",
	4: "content",
}

// Decode decodes MapSchema from json.
func (s *MapSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Skin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "x":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MapSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMapSchema) {
					name = jsonFieldsNameOfMapSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MapSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MapSchemaContent as json.
func (s MapSchemaContent) Encode(e *jx.Encoder) {
	switch s.Type {
	case MapContentSchemaMapSchemaContent:
		s.MapContentSchema.Encode(e)
	case NullMapSchemaContent:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes MapSchemaContent from json.
func (s *MapSchemaContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MapSchemaContent to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullMapSchemaContent
	case jx.Object:
		if err := s.MapContentSchema.Decode(d); err != nil {
			return err
		}
		s.Type = MapContentSchemaMapSchemaContent
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MapSchemaContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MapSchemaContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MonsterResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MonsterResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfMonsterResponseSchema = [1]string{
	0: "data",
}

// Decode decodes MonsterResponseSchema from json.
func (s *MonsterResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MonsterResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MonsterResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMonsterResponseSchema) {
					name = jsonFieldsNameOfMonsterResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MonsterResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MonsterResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MonsterSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MonsterSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("min_gold")
		e.Int(s.MinGold)
	}
	{
		e.FieldStart("max_gold")
		e.Int(s.MaxGold)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMonsterSchema = [15]string{
	0:  "name",
	1:  "code",
	2:  "level",
	3:  "hp",
	4:  "attack_fire",
	5:  "attack_earth",
	6:  "attack_water",
	7:  "attack_air",
	8:  "res_fire",
	9:  "res_earth",
	10: "res_water",
	11: "res_air",
	12: "min_gold",
	13: "max_gold",
	14: "drops",
}

// Decode decodes MonsterSchema from json.
func (s *MonsterSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MonsterSchema to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "hp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "attack_fire":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "res_fire":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "min_gold":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MinGold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_gold\"")
			}
		case "max_gold":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxGold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_gold\"")
			}
		case "drops":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Drops = make([]DropRateSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropRateSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MonsterSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMonsterSchema) {
					name = jsonFieldsNameOfMonsterSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MonsterSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MonsterSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MyAccountDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MyAccountDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("subscribed")
		e.Bool(s.Subscribed)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Badges.Set {
			e.FieldStart("badges")
			s.Badges.Encode(e)
		}
	}
	{
		e.FieldStart("gems")
		e.Int(s.Gems)
	}
	{
		e.FieldStart("achievements_points")
		e.Int(s.AchievementsPoints)
	}
	{
		e.FieldStart("banned")
		e.Bool(s.Banned)
	}
	{
		if s.BanReason.Set {
			e.FieldStart("ban_reason")
			s.BanReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfMyAccountDetails = [9]string{
	0: "username",
	1: "email",
	2: "subscribed",
	3: "status",
	4: "badges",
	5: "gems",
	6: "achievements_points",
	7: "banned",
	8: "ban_reason",
}

// Decode decodes MyAccountDetails from json.
func (s *MyAccountDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MyAccountDetails to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "subscribed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Subscribed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribed\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "badges":
			if err := func() error {
				s.Badges.Reset()
				if err := s.Badges.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"badges\"")
			}
		case "gems":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Gems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gems\"")
			}
		case "achievements_points":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AchievementsPoints = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievements_points\"")
			}
		case "banned":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Banned = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"banned\"")
			}
		case "ban_reason":
			if err := func() error {
				s.BanReason.Reset()
				if err := s.BanReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ban_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MyAccountDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMyAccountDetails) {
					name = jsonFieldsNameOfMyAccountDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MyAccountDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MyAccountDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MyAccountDetailsBadges as json.
func (s MyAccountDetailsBadges) Encode(e *jx.Encoder) {
	switch s.Type {
	case AnyArrayMyAccountDetailsBadges:
		e.ArrStart()
		for _, elem := range s.AnyArray {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	case NullMyAccountDetailsBadges:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes MyAccountDetailsBadges from json.
func (s *MyAccountDetailsBadges) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MyAccountDetailsBadges to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.AnyArray = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			s.AnyArray = append(s.AnyArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = AnyArrayMyAccountDetailsBadges
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullMyAccountDetailsBadges
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MyAccountDetailsBadges) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MyAccountDetailsBadges) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MyAccountDetailsSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MyAccountDetailsSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfMyAccountDetailsSchema = [1]string{
	0: "data",
}

// Decode decodes MyAccountDetailsSchema from json.
func (s *MyAccountDetailsSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MyAccountDetailsSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MyAccountDetailsSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMyAccountDetailsSchema) {
					name = jsonFieldsNameOfMyAccountDetailsSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MyAccountDetailsSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MyAccountDetailsSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MyAccountDetailsStatus as json.
func (s MyAccountDetailsStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MyAccountDetailsStatus from json.
func (s *MyAccountDetailsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MyAccountDetailsStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MyAccountDetailsStatus(v) {
	case MyAccountDetailsStatusStandard:
		*s = MyAccountDetailsStatusStandard
	case MyAccountDetailsStatusFounder:
		*s = MyAccountDetailsStatusFounder
	case MyAccountDetailsStatusGoldFounder:
		*s = MyAccountDetailsStatusGoldFounder
	case MyAccountDetailsStatusVipFounder:
		*s = MyAccountDetailsStatusVipFounder
	default:
		*s = MyAccountDetailsStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MyAccountDetailsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MyAccountDetailsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MyCharactersListSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MyCharactersListSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMyCharactersListSchema = [1]string{
	0: "data",
}

// Decode decodes MyCharactersListSchema from json.
func (s *MyCharactersListSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MyCharactersListSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CharacterSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MyCharactersListSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMyCharactersListSchema) {
					name = jsonFieldsNameOfMyCharactersListSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MyCharactersListSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MyCharactersListSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountDetailsBadges as json.
func (o OptAccountDetailsBadges) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AccountDetailsBadges from json.
func (o *OptAccountDetailsBadges) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccountDetailsBadges to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccountDetailsBadges) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccountDetailsBadges) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BankItemTransactionSchemaItemCraft as json.
func (o OptBankItemTransactionSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BankItemTransactionSchemaItemCraft from json.
func (o *OptBankItemTransactionSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBankItemTransactionSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBankItemTransactionSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBankItemTransactionSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CraftSchemaSkill as json.
func (o OptCraftSchemaSkill) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CraftSchemaSkill from json.
func (o *OptCraftSchemaSkill) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCraftSchemaSkill to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCraftSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCraftSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountAchievementSchemaPages as json.
func (o OptDataPageAccountAchievementSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageAccountAchievementSchemaPages from json.
func (o *OptDataPageAccountAchievementSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageAccountAchievementSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageAccountAchievementSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageAccountAchievementSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAccountLeaderboardSchemaPages as json.
func (o OptDataPageAccountLeaderboardSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageAccountLeaderboardSchemaPages from json.
func (o *OptDataPageAccountLeaderboardSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageAccountLeaderboardSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageAccountLeaderboardSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageAccountLeaderboardSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageAchievementSchemaPages as json.
func (o OptDataPageAchievementSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageAchievementSchemaPages from json.
func (o *OptDataPageAchievementSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageAchievementSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageAchievementSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageAchievementSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageActiveEventSchemaPages as json.
func (o OptDataPageActiveEventSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageActiveEventSchemaPages from json.
func (o *OptDataPageActiveEventSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageActiveEventSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageActiveEventSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageActiveEventSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageCharacterLeaderboardSchemaPages as json.
func (o OptDataPageCharacterLeaderboardSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageCharacterLeaderboardSchemaPages from json.
func (o *OptDataPageCharacterLeaderboardSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageCharacterLeaderboardSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageCharacterLeaderboardSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageCharacterLeaderboardSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageDropRateSchemaPages as json.
func (o OptDataPageDropRateSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageDropRateSchemaPages from json.
func (o *OptDataPageDropRateSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageDropRateSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageDropRateSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageDropRateSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageEventSchemaPages as json.
func (o OptDataPageEventSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageEventSchemaPages from json.
func (o *OptDataPageEventSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageEventSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageEventSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageEventSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGEOrderSchemaPages as json.
func (o OptDataPageGEOrderSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageGEOrderSchemaPages from json.
func (o *OptDataPageGEOrderSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageGEOrderSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageGEOrderSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageGEOrderSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageGeOrderHistorySchemaPages as json.
func (o OptDataPageGeOrderHistorySchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageGeOrderHistorySchemaPages from json.
func (o *OptDataPageGeOrderHistorySchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageGeOrderHistorySchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageGeOrderHistorySchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageGeOrderHistorySchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageItemSchemaPages as json.
func (o OptDataPageItemSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageItemSchemaPages from json.
func (o *OptDataPageItemSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageItemSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageLogSchemaPages as json.
func (o OptDataPageLogSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageLogSchemaPages from json.
func (o *OptDataPageLogSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageLogSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageLogSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageLogSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMapSchemaPages as json.
func (o OptDataPageMapSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageMapSchemaPages from json.
func (o *OptDataPageMapSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageMapSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageMapSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageMapSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageMonsterSchemaPages as json.
func (o OptDataPageMonsterSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageMonsterSchemaPages from json.
func (o *OptDataPageMonsterSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageMonsterSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageMonsterSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageMonsterSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageResourceSchemaPages as json.
func (o OptDataPageResourceSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageResourceSchemaPages from json.
func (o *OptDataPageResourceSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageResourceSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageResourceSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageResourceSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageSimpleItemSchemaPages as json.
func (o OptDataPageSimpleItemSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageSimpleItemSchemaPages from json.
func (o *OptDataPageSimpleItemSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageSimpleItemSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageSimpleItemSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageSimpleItemSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DataPageTaskFullSchemaPages as json.
func (o OptDataPageTaskFullSchemaPages) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DataPageTaskFullSchemaPages from json.
func (o *OptDataPageTaskFullSchemaPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDataPageTaskFullSchemaPages to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDataPageTaskFullSchemaPages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDataPageTaskFullSchemaPages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes EquipRequestSchemaItemCraft as json.
func (o OptEquipRequestSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EquipRequestSchemaItemCraft from json.
func (o *OptEquipRequestSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEquipRequestSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEquipRequestSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEquipRequestSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ItemSchemaCraft as json.
func (o OptItemSchemaCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ItemSchemaCraft from json.
func (o *OptItemSchemaCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptItemSchemaCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptItemSchemaCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptItemSchemaCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MyAccountDetailsBadges as json.
func (o OptMyAccountDetailsBadges) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MyAccountDetailsBadges from json.
func (o *OptMyAccountDetailsBadges) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMyAccountDetailsBadges to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMyAccountDetailsBadges) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMyAccountDetailsBadges) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UseItemSchemaItemCraft as json.
func (o OptUseItemSchemaItemCraft) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UseItemSchemaItemCraft from json.
func (o *OptUseItemSchemaItemCraft) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUseItemSchemaItemCraft to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUseItemSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUseItemSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingDataSchema = [3]string{
	0: "cooldown",
	1: "details",
	2: "character",
}

// Decode decodes RecyclingDataSchema from json.
func (s *RecyclingDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchema) {
					name = jsonFieldsNameOfRecyclingDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRecyclingDataSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes RecyclingDataSchemaCharacter from json.
func (s *RecyclingDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaCharacter) {
					name = jsonFieldsNameOfRecyclingDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecyclingDataSchemaCharacterSkin as json.
func (s RecyclingDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecyclingDataSchemaCharacterSkin from json.
func (s *RecyclingDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecyclingDataSchemaCharacterSkin(v) {
	case RecyclingDataSchemaCharacterSkinMen1:
		*s = RecyclingDataSchemaCharacterSkinMen1
	case RecyclingDataSchemaCharacterSkinMen2:
		*s = RecyclingDataSchemaCharacterSkinMen2
	case RecyclingDataSchemaCharacterSkinMen3:
		*s = RecyclingDataSchemaCharacterSkinMen3
	case RecyclingDataSchemaCharacterSkinWomen1:
		*s = RecyclingDataSchemaCharacterSkinWomen1
	case RecyclingDataSchemaCharacterSkinWomen2:
		*s = RecyclingDataSchemaCharacterSkinWomen2
	case RecyclingDataSchemaCharacterSkinWomen3:
		*s = RecyclingDataSchemaCharacterSkinWomen3
	default:
		*s = RecyclingDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecyclingDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes RecyclingDataSchemaCooldown from json.
func (s *RecyclingDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaCooldown) {
					name = jsonFieldsNameOfRecyclingDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecyclingDataSchemaCooldownReason as json.
func (s RecyclingDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecyclingDataSchemaCooldownReason from json.
func (s *RecyclingDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecyclingDataSchemaCooldownReason(v) {
	case RecyclingDataSchemaCooldownReasonMovement:
		*s = RecyclingDataSchemaCooldownReasonMovement
	case RecyclingDataSchemaCooldownReasonFight:
		*s = RecyclingDataSchemaCooldownReasonFight
	case RecyclingDataSchemaCooldownReasonCrafting:
		*s = RecyclingDataSchemaCooldownReasonCrafting
	case RecyclingDataSchemaCooldownReasonGathering:
		*s = RecyclingDataSchemaCooldownReasonGathering
	case RecyclingDataSchemaCooldownReasonBuyGe:
		*s = RecyclingDataSchemaCooldownReasonBuyGe
	case RecyclingDataSchemaCooldownReasonSellGe:
		*s = RecyclingDataSchemaCooldownReasonSellGe
	case RecyclingDataSchemaCooldownReasonCancelGe:
		*s = RecyclingDataSchemaCooldownReasonCancelGe
	case RecyclingDataSchemaCooldownReasonDeleteItem:
		*s = RecyclingDataSchemaCooldownReasonDeleteItem
	case RecyclingDataSchemaCooldownReasonDeposit:
		*s = RecyclingDataSchemaCooldownReasonDeposit
	case RecyclingDataSchemaCooldownReasonWithdraw:
		*s = RecyclingDataSchemaCooldownReasonWithdraw
	case RecyclingDataSchemaCooldownReasonDepositGold:
		*s = RecyclingDataSchemaCooldownReasonDepositGold
	case RecyclingDataSchemaCooldownReasonWithdrawGold:
		*s = RecyclingDataSchemaCooldownReasonWithdrawGold
	case RecyclingDataSchemaCooldownReasonEquip:
		*s = RecyclingDataSchemaCooldownReasonEquip
	case RecyclingDataSchemaCooldownReasonUnequip:
		*s = RecyclingDataSchemaCooldownReasonUnequip
	case RecyclingDataSchemaCooldownReasonTask:
		*s = RecyclingDataSchemaCooldownReasonTask
	case RecyclingDataSchemaCooldownReasonRecycling:
		*s = RecyclingDataSchemaCooldownReasonRecycling
	case RecyclingDataSchemaCooldownReasonRest:
		*s = RecyclingDataSchemaCooldownReasonRest
	case RecyclingDataSchemaCooldownReasonUse:
		*s = RecyclingDataSchemaCooldownReasonUse
	case RecyclingDataSchemaCooldownReasonBuyBankExpansion:
		*s = RecyclingDataSchemaCooldownReasonBuyBankExpansion
	default:
		*s = RecyclingDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecyclingDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingDataSchemaDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingDataSchemaDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRecyclingDataSchemaDetails = [1]string{
	0: "items",
}

// Decode decodes RecyclingDataSchemaDetails from json.
func (s *RecyclingDataSchemaDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingDataSchemaDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingDataSchemaDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingDataSchemaDetails) {
					name = jsonFieldsNameOfRecyclingDataSchemaDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingDataSchemaDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingDataSchemaDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfRecyclingResponseSchema = [1]string{
	0: "data",
}

// Decode decodes RecyclingResponseSchema from json.
func (s *RecyclingResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingResponseSchema) {
					name = jsonFieldsNameOfRecyclingResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecyclingSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecyclingSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecyclingSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes RecyclingSchema from json.
func (s *RecyclingSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecyclingSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecyclingSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecyclingSchema) {
					name = jsonFieldsNameOfRecyclingSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecyclingSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecyclingSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfResourceResponseSchema = [1]string{
	0: "data",
}

// Decode decodes ResourceResponseSchema from json.
func (s *ResourceResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceResponseSchema) {
					name = jsonFieldsNameOfResourceResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("skill")
		s.Skill.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("drops")
		e.ArrStart()
		for _, elem := range s.Drops {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfResourceSchema = [5]string{
	0: "name",
	1: "code",
	2: "skill",
	3: "level",
	4: "drops",
}

// Decode decodes ResourceSchema from json.
func (s *ResourceSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "skill":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "drops":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Drops = make([]DropRateSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropRateSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drops = append(s.Drops, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drops\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceSchema) {
					name = jsonFieldsNameOfResourceSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceSchemaSkill as json.
func (s ResourceSchemaSkill) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceSchemaSkill from json.
func (s *ResourceSchemaSkill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceSchemaSkill to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceSchemaSkill(v) {
	case ResourceSchemaSkillMining:
		*s = ResourceSchemaSkillMining
	case ResourceSchemaSkillWoodcutting:
		*s = ResourceSchemaSkillWoodcutting
	case ResourceSchemaSkillFishing:
		*s = ResourceSchemaSkillFishing
	case ResourceSchemaSkillAlchemy:
		*s = ResourceSchemaSkillAlchemy
	default:
		*s = ResourceSchemaSkill(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfResponseSchema = [1]string{
	0: "message",
}

// Decode decodes ResponseSchema from json.
func (s *ResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResponseSchema) {
					name = jsonFieldsNameOfResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimpleItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimpleItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfSimpleItemSchema = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes SimpleItemSchema from json.
func (s *SimpleItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleItemSchema) {
					name = jsonFieldsNameOfSimpleItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimpleItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimpleItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfSkillDataSchema = [3]string{
	0: "cooldown",
	1: "details",
	2: "character",
}

// Decode decodes SkillDataSchema from json.
func (s *SkillDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchema) {
					name = jsonFieldsNameOfSkillDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSkillDataSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes SkillDataSchemaCharacter from json.
func (s *SkillDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaCharacter) {
					name = jsonFieldsNameOfSkillDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkillDataSchemaCharacterSkin as json.
func (s SkillDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SkillDataSchemaCharacterSkin from json.
func (s *SkillDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SkillDataSchemaCharacterSkin(v) {
	case SkillDataSchemaCharacterSkinMen1:
		*s = SkillDataSchemaCharacterSkinMen1
	case SkillDataSchemaCharacterSkinMen2:
		*s = SkillDataSchemaCharacterSkinMen2
	case SkillDataSchemaCharacterSkinMen3:
		*s = SkillDataSchemaCharacterSkinMen3
	case SkillDataSchemaCharacterSkinWomen1:
		*s = SkillDataSchemaCharacterSkinWomen1
	case SkillDataSchemaCharacterSkinWomen2:
		*s = SkillDataSchemaCharacterSkinWomen2
	case SkillDataSchemaCharacterSkinWomen3:
		*s = SkillDataSchemaCharacterSkinWomen3
	default:
		*s = SkillDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkillDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfSkillDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes SkillDataSchemaCooldown from json.
func (s *SkillDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaCooldown) {
					name = jsonFieldsNameOfSkillDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkillDataSchemaCooldownReason as json.
func (s SkillDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SkillDataSchemaCooldownReason from json.
func (s *SkillDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SkillDataSchemaCooldownReason(v) {
	case SkillDataSchemaCooldownReasonMovement:
		*s = SkillDataSchemaCooldownReasonMovement
	case SkillDataSchemaCooldownReasonFight:
		*s = SkillDataSchemaCooldownReasonFight
	case SkillDataSchemaCooldownReasonCrafting:
		*s = SkillDataSchemaCooldownReasonCrafting
	case SkillDataSchemaCooldownReasonGathering:
		*s = SkillDataSchemaCooldownReasonGathering
	case SkillDataSchemaCooldownReasonBuyGe:
		*s = SkillDataSchemaCooldownReasonBuyGe
	case SkillDataSchemaCooldownReasonSellGe:
		*s = SkillDataSchemaCooldownReasonSellGe
	case SkillDataSchemaCooldownReasonCancelGe:
		*s = SkillDataSchemaCooldownReasonCancelGe
	case SkillDataSchemaCooldownReasonDeleteItem:
		*s = SkillDataSchemaCooldownReasonDeleteItem
	case SkillDataSchemaCooldownReasonDeposit:
		*s = SkillDataSchemaCooldownReasonDeposit
	case SkillDataSchemaCooldownReasonWithdraw:
		*s = SkillDataSchemaCooldownReasonWithdraw
	case SkillDataSchemaCooldownReasonDepositGold:
		*s = SkillDataSchemaCooldownReasonDepositGold
	case SkillDataSchemaCooldownReasonWithdrawGold:
		*s = SkillDataSchemaCooldownReasonWithdrawGold
	case SkillDataSchemaCooldownReasonEquip:
		*s = SkillDataSchemaCooldownReasonEquip
	case SkillDataSchemaCooldownReasonUnequip:
		*s = SkillDataSchemaCooldownReasonUnequip
	case SkillDataSchemaCooldownReasonTask:
		*s = SkillDataSchemaCooldownReasonTask
	case SkillDataSchemaCooldownReasonRecycling:
		*s = SkillDataSchemaCooldownReasonRecycling
	case SkillDataSchemaCooldownReasonRest:
		*s = SkillDataSchemaCooldownReasonRest
	case SkillDataSchemaCooldownReasonUse:
		*s = SkillDataSchemaCooldownReasonUse
	case SkillDataSchemaCooldownReasonBuyBankExpansion:
		*s = SkillDataSchemaCooldownReasonBuyBankExpansion
	default:
		*s = SkillDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkillDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillDataSchemaDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillDataSchemaDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSkillDataSchemaDetails = [2]string{
	0: "xp",
	1: "items",
}

// Decode decodes SkillDataSchemaDetails from json.
func (s *SkillDataSchemaDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillDataSchemaDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "xp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Items = make([]DropSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DropSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillDataSchemaDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillDataSchemaDetails) {
					name = jsonFieldsNameOfSkillDataSchemaDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillDataSchemaDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillDataSchemaDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkillResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkillResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfSkillResponseSchema = [1]string{
	0: "data",
}

// Decode decodes SkillResponseSchema from json.
func (s *SkillResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkillResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkillResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSkillResponseSchema) {
					name = jsonFieldsNameOfSkillResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkillResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkillResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatusResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatusResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfStatusResponseSchema = [1]string{
	0: "data",
}

// Decode decodes StatusResponseSchema from json.
func (s *StatusResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusResponseSchema) {
					name = jsonFieldsNameOfStatusResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatusResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StatusSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StatusSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("max_level")
		e.Int(s.MaxLevel)
	}
	{
		e.FieldStart("characters_online")
		e.Int(s.CharactersOnline)
	}
	{
		e.FieldStart("server_time")
		json.EncodeDateTime(e, s.ServerTime)
	}
	{
		e.FieldStart("announcements")
		e.ArrStart()
		for _, elem := range s.Announcements {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("last_wipe")
		e.Str(s.LastWipe)
	}
	{
		e.FieldStart("next_wipe")
		e.Str(s.NextWipe)
	}
}

var jsonFieldsNameOfStatusSchema = [8]string{
	0: "status",
	1: "version",
	2: "max_level",
	3: "characters_online",
	4: "server_time",
	5: "announcements",
	6: "last_wipe",
	7: "next_wipe",
}

// Decode decodes StatusSchema from json.
func (s *StatusSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "max_level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MaxLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_level\"")
			}
		case "characters_online":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CharactersOnline = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters_online\"")
			}
		case "server_time":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ServerTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_time\"")
			}
		case "announcements":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Announcements = make([]AnnouncementSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnnouncementSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Announcements = append(s.Announcements, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"announcements\"")
			}
		case "last_wipe":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.LastWipe = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_wipe\"")
			}
		case "next_wipe":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NextWipe = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_wipe\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusSchema) {
					name = jsonFieldsNameOfStatusSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StatusSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StatusSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskCancelledResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskCancelledResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskCancelledResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskCancelledResponseSchema from json.
func (s *TaskCancelledResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskCancelledResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskCancelledResponseSchema) {
					name = jsonFieldsNameOfTaskCancelledResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskCancelledResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskCancelledSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskCancelledSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTaskCancelledSchema = [2]string{
	0: "cooldown",
	1: "character",
}

// Decode decodes TaskCancelledSchema from json.
func (s *TaskCancelledSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskCancelledSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskCancelledSchema) {
					name = jsonFieldsNameOfTaskCancelledSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskCancelledSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskCancelledSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskCancelledSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTaskCancelledSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes TaskCancelledSchemaCharacter from json.
func (s *TaskCancelledSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskCancelledSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskCancelledSchemaCharacter) {
					name = jsonFieldsNameOfTaskCancelledSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskCancelledSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskCancelledSchemaCharacterSkin as json.
func (s TaskCancelledSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskCancelledSchemaCharacterSkin from json.
func (s *TaskCancelledSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskCancelledSchemaCharacterSkin(v) {
	case TaskCancelledSchemaCharacterSkinMen1:
		*s = TaskCancelledSchemaCharacterSkinMen1
	case TaskCancelledSchemaCharacterSkinMen2:
		*s = TaskCancelledSchemaCharacterSkinMen2
	case TaskCancelledSchemaCharacterSkinMen3:
		*s = TaskCancelledSchemaCharacterSkinMen3
	case TaskCancelledSchemaCharacterSkinWomen1:
		*s = TaskCancelledSchemaCharacterSkinWomen1
	case TaskCancelledSchemaCharacterSkinWomen2:
		*s = TaskCancelledSchemaCharacterSkinWomen2
	case TaskCancelledSchemaCharacterSkinWomen3:
		*s = TaskCancelledSchemaCharacterSkinWomen3
	default:
		*s = TaskCancelledSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskCancelledSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskCancelledSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskCancelledSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTaskCancelledSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes TaskCancelledSchemaCooldown from json.
func (s *TaskCancelledSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskCancelledSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskCancelledSchemaCooldown) {
					name = jsonFieldsNameOfTaskCancelledSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskCancelledSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskCancelledSchemaCooldownReason as json.
func (s TaskCancelledSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskCancelledSchemaCooldownReason from json.
func (s *TaskCancelledSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskCancelledSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskCancelledSchemaCooldownReason(v) {
	case TaskCancelledSchemaCooldownReasonMovement:
		*s = TaskCancelledSchemaCooldownReasonMovement
	case TaskCancelledSchemaCooldownReasonFight:
		*s = TaskCancelledSchemaCooldownReasonFight
	case TaskCancelledSchemaCooldownReasonCrafting:
		*s = TaskCancelledSchemaCooldownReasonCrafting
	case TaskCancelledSchemaCooldownReasonGathering:
		*s = TaskCancelledSchemaCooldownReasonGathering
	case TaskCancelledSchemaCooldownReasonBuyGe:
		*s = TaskCancelledSchemaCooldownReasonBuyGe
	case TaskCancelledSchemaCooldownReasonSellGe:
		*s = TaskCancelledSchemaCooldownReasonSellGe
	case TaskCancelledSchemaCooldownReasonCancelGe:
		*s = TaskCancelledSchemaCooldownReasonCancelGe
	case TaskCancelledSchemaCooldownReasonDeleteItem:
		*s = TaskCancelledSchemaCooldownReasonDeleteItem
	case TaskCancelledSchemaCooldownReasonDeposit:
		*s = TaskCancelledSchemaCooldownReasonDeposit
	case TaskCancelledSchemaCooldownReasonWithdraw:
		*s = TaskCancelledSchemaCooldownReasonWithdraw
	case TaskCancelledSchemaCooldownReasonDepositGold:
		*s = TaskCancelledSchemaCooldownReasonDepositGold
	case TaskCancelledSchemaCooldownReasonWithdrawGold:
		*s = TaskCancelledSchemaCooldownReasonWithdrawGold
	case TaskCancelledSchemaCooldownReasonEquip:
		*s = TaskCancelledSchemaCooldownReasonEquip
	case TaskCancelledSchemaCooldownReasonUnequip:
		*s = TaskCancelledSchemaCooldownReasonUnequip
	case TaskCancelledSchemaCooldownReasonTask:
		*s = TaskCancelledSchemaCooldownReasonTask
	case TaskCancelledSchemaCooldownReasonRecycling:
		*s = TaskCancelledSchemaCooldownReasonRecycling
	case TaskCancelledSchemaCooldownReasonRest:
		*s = TaskCancelledSchemaCooldownReasonRest
	case TaskCancelledSchemaCooldownReasonUse:
		*s = TaskCancelledSchemaCooldownReasonUse
	case TaskCancelledSchemaCooldownReasonBuyBankExpansion:
		*s = TaskCancelledSchemaCooldownReasonBuyBankExpansion
	default:
		*s = TaskCancelledSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskCancelledSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskCancelledSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("task")
		s.Task.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTaskDataSchema = [3]string{
	0: "cooldown",
	1: "task",
	2: "character",
}

// Decode decodes TaskDataSchema from json.
func (s *TaskDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "task":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Task.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchema) {
					name = jsonFieldsNameOfTaskDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTaskDataSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes TaskDataSchemaCharacter from json.
func (s *TaskDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaCharacter) {
					name = jsonFieldsNameOfTaskDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaCharacterSkin as json.
func (s TaskDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaCharacterSkin from json.
func (s *TaskDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaCharacterSkin(v) {
	case TaskDataSchemaCharacterSkinMen1:
		*s = TaskDataSchemaCharacterSkinMen1
	case TaskDataSchemaCharacterSkinMen2:
		*s = TaskDataSchemaCharacterSkinMen2
	case TaskDataSchemaCharacterSkinMen3:
		*s = TaskDataSchemaCharacterSkinMen3
	case TaskDataSchemaCharacterSkinWomen1:
		*s = TaskDataSchemaCharacterSkinWomen1
	case TaskDataSchemaCharacterSkinWomen2:
		*s = TaskDataSchemaCharacterSkinWomen2
	case TaskDataSchemaCharacterSkinWomen3:
		*s = TaskDataSchemaCharacterSkinWomen3
	default:
		*s = TaskDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTaskDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes TaskDataSchemaCooldown from json.
func (s *TaskDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaCooldown) {
					name = jsonFieldsNameOfTaskDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaCooldownReason as json.
func (s TaskDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaCooldownReason from json.
func (s *TaskDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaCooldownReason(v) {
	case TaskDataSchemaCooldownReasonMovement:
		*s = TaskDataSchemaCooldownReasonMovement
	case TaskDataSchemaCooldownReasonFight:
		*s = TaskDataSchemaCooldownReasonFight
	case TaskDataSchemaCooldownReasonCrafting:
		*s = TaskDataSchemaCooldownReasonCrafting
	case TaskDataSchemaCooldownReasonGathering:
		*s = TaskDataSchemaCooldownReasonGathering
	case TaskDataSchemaCooldownReasonBuyGe:
		*s = TaskDataSchemaCooldownReasonBuyGe
	case TaskDataSchemaCooldownReasonSellGe:
		*s = TaskDataSchemaCooldownReasonSellGe
	case TaskDataSchemaCooldownReasonCancelGe:
		*s = TaskDataSchemaCooldownReasonCancelGe
	case TaskDataSchemaCooldownReasonDeleteItem:
		*s = TaskDataSchemaCooldownReasonDeleteItem
	case TaskDataSchemaCooldownReasonDeposit:
		*s = TaskDataSchemaCooldownReasonDeposit
	case TaskDataSchemaCooldownReasonWithdraw:
		*s = TaskDataSchemaCooldownReasonWithdraw
	case TaskDataSchemaCooldownReasonDepositGold:
		*s = TaskDataSchemaCooldownReasonDepositGold
	case TaskDataSchemaCooldownReasonWithdrawGold:
		*s = TaskDataSchemaCooldownReasonWithdrawGold
	case TaskDataSchemaCooldownReasonEquip:
		*s = TaskDataSchemaCooldownReasonEquip
	case TaskDataSchemaCooldownReasonUnequip:
		*s = TaskDataSchemaCooldownReasonUnequip
	case TaskDataSchemaCooldownReasonTask:
		*s = TaskDataSchemaCooldownReasonTask
	case TaskDataSchemaCooldownReasonRecycling:
		*s = TaskDataSchemaCooldownReasonRecycling
	case TaskDataSchemaCooldownReasonRest:
		*s = TaskDataSchemaCooldownReasonRest
	case TaskDataSchemaCooldownReasonUse:
		*s = TaskDataSchemaCooldownReasonUse
	case TaskDataSchemaCooldownReasonBuyBankExpansion:
		*s = TaskDataSchemaCooldownReasonBuyBankExpansion
	default:
		*s = TaskDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaTask) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
}

var jsonFieldsNameOfTaskDataSchemaTask = [4]string{
	0: "code",
	1: "type",
	2: "total",
	3: "rewards",
}

// Decode decodes TaskDataSchemaTask from json.
func (s *TaskDataSchemaTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaTask to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaTask) {
					name = jsonFieldsNameOfTaskDataSchemaTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskDataSchemaTaskRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskDataSchemaTaskRewards) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfTaskDataSchemaTaskRewards = [2]string{
	0: "items",
	1: "gold",
}

// Decode decodes TaskDataSchemaTaskRewards from json.
func (s *TaskDataSchemaTaskRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaTaskRewards to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskDataSchemaTaskRewards")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskDataSchemaTaskRewards) {
					name = jsonFieldsNameOfTaskDataSchemaTaskRewards[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskDataSchemaTaskRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaTaskRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskDataSchemaTaskType as json.
func (s TaskDataSchemaTaskType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskDataSchemaTaskType from json.
func (s *TaskDataSchemaTaskType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskDataSchemaTaskType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskDataSchemaTaskType(v) {
	case TaskDataSchemaTaskTypeMonsters:
		*s = TaskDataSchemaTaskTypeMonsters
	case TaskDataSchemaTaskTypeItems:
		*s = TaskDataSchemaTaskTypeItems
	default:
		*s = TaskDataSchemaTaskType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskDataSchemaTaskType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskDataSchemaTaskType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskFullResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskFullResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskFullResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskFullResponseSchema from json.
func (s *TaskFullResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskFullResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskFullResponseSchema) {
					name = jsonFieldsNameOfTaskFullResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskFullResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskFullSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskFullSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("min_quantity")
		e.Int(s.MinQuantity)
	}
	{
		e.FieldStart("max_quantity")
		e.Int(s.MaxQuantity)
	}
	{
		e.FieldStart("skill")
		s.Skill.Encode(e)
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
}

var jsonFieldsNameOfTaskFullSchema = [7]string{
	0: "code",
	1: "level",
	2: "type",
	3: "min_quantity",
	4: "max_quantity",
	5: "skill",
	6: "rewards",
}

// Decode decodes TaskFullSchema from json.
func (s *TaskFullSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "min_quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.MinQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_quantity\"")
			}
		case "max_quantity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_quantity\"")
			}
		case "skill":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Skill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskFullSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskFullSchema) {
					name = jsonFieldsNameOfTaskFullSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskFullSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskFullSchemaRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskFullSchemaRewards) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfTaskFullSchemaRewards = [2]string{
	0: "items",
	1: "gold",
}

// Decode decodes TaskFullSchemaRewards from json.
func (s *TaskFullSchemaRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullSchemaRewards to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskFullSchemaRewards")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskFullSchemaRewards) {
					name = jsonFieldsNameOfTaskFullSchemaRewards[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskFullSchemaRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullSchemaRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskFullSchemaSkill as json.
func (s TaskFullSchemaSkill) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringTaskFullSchemaSkill:
		e.Str(s.String)
	case NullTaskFullSchemaSkill:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes TaskFullSchemaSkill from json.
func (s *TaskFullSchemaSkill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullSchemaSkill to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullTaskFullSchemaSkill
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringTaskFullSchemaSkill
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskFullSchemaSkill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullSchemaSkill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskFullSchemaType as json.
func (s TaskFullSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskFullSchemaType from json.
func (s *TaskFullSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskFullSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskFullSchemaType(v) {
	case TaskFullSchemaTypeMonsters:
		*s = TaskFullSchemaTypeMonsters
	case TaskFullSchemaTypeItems:
		*s = TaskFullSchemaTypeItems
	default:
		*s = TaskFullSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskFullSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskFullSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskResponseSchema from json.
func (s *TaskResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskResponseSchema) {
					name = jsonFieldsNameOfTaskResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("trade")
		s.Trade.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTaskTradeDataSchema = [3]string{
	0: "cooldown",
	1: "trade",
	2: "character",
}

// Decode decodes TaskTradeDataSchema from json.
func (s *TaskTradeDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "trade":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Trade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trade\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeDataSchema) {
					name = jsonFieldsNameOfTaskTradeDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTaskTradeDataSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes TaskTradeDataSchemaCharacter from json.
func (s *TaskTradeDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeDataSchemaCharacter) {
					name = jsonFieldsNameOfTaskTradeDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskTradeDataSchemaCharacterSkin as json.
func (s TaskTradeDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskTradeDataSchemaCharacterSkin from json.
func (s *TaskTradeDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskTradeDataSchemaCharacterSkin(v) {
	case TaskTradeDataSchemaCharacterSkinMen1:
		*s = TaskTradeDataSchemaCharacterSkinMen1
	case TaskTradeDataSchemaCharacterSkinMen2:
		*s = TaskTradeDataSchemaCharacterSkinMen2
	case TaskTradeDataSchemaCharacterSkinMen3:
		*s = TaskTradeDataSchemaCharacterSkinMen3
	case TaskTradeDataSchemaCharacterSkinWomen1:
		*s = TaskTradeDataSchemaCharacterSkinWomen1
	case TaskTradeDataSchemaCharacterSkinWomen2:
		*s = TaskTradeDataSchemaCharacterSkinWomen2
	case TaskTradeDataSchemaCharacterSkinWomen3:
		*s = TaskTradeDataSchemaCharacterSkinWomen3
	default:
		*s = TaskTradeDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskTradeDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTaskTradeDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes TaskTradeDataSchemaCooldown from json.
func (s *TaskTradeDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeDataSchemaCooldown) {
					name = jsonFieldsNameOfTaskTradeDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskTradeDataSchemaCooldownReason as json.
func (s TaskTradeDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TaskTradeDataSchemaCooldownReason from json.
func (s *TaskTradeDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TaskTradeDataSchemaCooldownReason(v) {
	case TaskTradeDataSchemaCooldownReasonMovement:
		*s = TaskTradeDataSchemaCooldownReasonMovement
	case TaskTradeDataSchemaCooldownReasonFight:
		*s = TaskTradeDataSchemaCooldownReasonFight
	case TaskTradeDataSchemaCooldownReasonCrafting:
		*s = TaskTradeDataSchemaCooldownReasonCrafting
	case TaskTradeDataSchemaCooldownReasonGathering:
		*s = TaskTradeDataSchemaCooldownReasonGathering
	case TaskTradeDataSchemaCooldownReasonBuyGe:
		*s = TaskTradeDataSchemaCooldownReasonBuyGe
	case TaskTradeDataSchemaCooldownReasonSellGe:
		*s = TaskTradeDataSchemaCooldownReasonSellGe
	case TaskTradeDataSchemaCooldownReasonCancelGe:
		*s = TaskTradeDataSchemaCooldownReasonCancelGe
	case TaskTradeDataSchemaCooldownReasonDeleteItem:
		*s = TaskTradeDataSchemaCooldownReasonDeleteItem
	case TaskTradeDataSchemaCooldownReasonDeposit:
		*s = TaskTradeDataSchemaCooldownReasonDeposit
	case TaskTradeDataSchemaCooldownReasonWithdraw:
		*s = TaskTradeDataSchemaCooldownReasonWithdraw
	case TaskTradeDataSchemaCooldownReasonDepositGold:
		*s = TaskTradeDataSchemaCooldownReasonDepositGold
	case TaskTradeDataSchemaCooldownReasonWithdrawGold:
		*s = TaskTradeDataSchemaCooldownReasonWithdrawGold
	case TaskTradeDataSchemaCooldownReasonEquip:
		*s = TaskTradeDataSchemaCooldownReasonEquip
	case TaskTradeDataSchemaCooldownReasonUnequip:
		*s = TaskTradeDataSchemaCooldownReasonUnequip
	case TaskTradeDataSchemaCooldownReasonTask:
		*s = TaskTradeDataSchemaCooldownReasonTask
	case TaskTradeDataSchemaCooldownReasonRecycling:
		*s = TaskTradeDataSchemaCooldownReasonRecycling
	case TaskTradeDataSchemaCooldownReasonRest:
		*s = TaskTradeDataSchemaCooldownReasonRest
	case TaskTradeDataSchemaCooldownReasonUse:
		*s = TaskTradeDataSchemaCooldownReasonUse
	case TaskTradeDataSchemaCooldownReasonBuyBankExpansion:
		*s = TaskTradeDataSchemaCooldownReasonBuyBankExpansion
	default:
		*s = TaskTradeDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TaskTradeDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeDataSchemaTrade) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeDataSchemaTrade) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("quantity")
		e.Int(s.Quantity)
	}
}

var jsonFieldsNameOfTaskTradeDataSchemaTrade = [2]string{
	0: "code",
	1: "quantity",
}

// Decode decodes TaskTradeDataSchemaTrade from json.
func (s *TaskTradeDataSchemaTrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeDataSchemaTrade to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Quantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeDataSchemaTrade")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeDataSchemaTrade) {
					name = jsonFieldsNameOfTaskTradeDataSchemaTrade[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeDataSchemaTrade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeDataSchemaTrade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskTradeResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskTradeResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTaskTradeResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TaskTradeResponseSchema from json.
func (s *TaskTradeResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskTradeResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskTradeResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskTradeResponseSchema) {
					name = jsonFieldsNameOfTaskTradeResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskTradeResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskTradeResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTasksRewardDataResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TasksRewardDataResponseSchema from json.
func (s *TasksRewardDataResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataResponseSchema) {
					name = jsonFieldsNameOfTasksRewardDataResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("rewards")
		s.Rewards.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfTasksRewardDataSchema = [3]string{
	0: "cooldown",
	1: "rewards",
	2: "character",
}

// Decode decodes TasksRewardDataSchema from json.
func (s *TasksRewardDataSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "rewards":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Rewards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewards\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataSchema) {
					name = jsonFieldsNameOfTasksRewardDataSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTasksRewardDataSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes TasksRewardDataSchemaCharacter from json.
func (s *TasksRewardDataSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataSchemaCharacter) {
					name = jsonFieldsNameOfTasksRewardDataSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TasksRewardDataSchemaCharacterSkin as json.
func (s TasksRewardDataSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TasksRewardDataSchemaCharacterSkin from json.
func (s *TasksRewardDataSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TasksRewardDataSchemaCharacterSkin(v) {
	case TasksRewardDataSchemaCharacterSkinMen1:
		*s = TasksRewardDataSchemaCharacterSkinMen1
	case TasksRewardDataSchemaCharacterSkinMen2:
		*s = TasksRewardDataSchemaCharacterSkinMen2
	case TasksRewardDataSchemaCharacterSkinMen3:
		*s = TasksRewardDataSchemaCharacterSkinMen3
	case TasksRewardDataSchemaCharacterSkinWomen1:
		*s = TasksRewardDataSchemaCharacterSkinWomen1
	case TasksRewardDataSchemaCharacterSkinWomen2:
		*s = TasksRewardDataSchemaCharacterSkinWomen2
	case TasksRewardDataSchemaCharacterSkinWomen3:
		*s = TasksRewardDataSchemaCharacterSkinWomen3
	default:
		*s = TasksRewardDataSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TasksRewardDataSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfTasksRewardDataSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes TasksRewardDataSchemaCooldown from json.
func (s *TasksRewardDataSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataSchemaCooldown) {
					name = jsonFieldsNameOfTasksRewardDataSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TasksRewardDataSchemaCooldownReason as json.
func (s TasksRewardDataSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TasksRewardDataSchemaCooldownReason from json.
func (s *TasksRewardDataSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TasksRewardDataSchemaCooldownReason(v) {
	case TasksRewardDataSchemaCooldownReasonMovement:
		*s = TasksRewardDataSchemaCooldownReasonMovement
	case TasksRewardDataSchemaCooldownReasonFight:
		*s = TasksRewardDataSchemaCooldownReasonFight
	case TasksRewardDataSchemaCooldownReasonCrafting:
		*s = TasksRewardDataSchemaCooldownReasonCrafting
	case TasksRewardDataSchemaCooldownReasonGathering:
		*s = TasksRewardDataSchemaCooldownReasonGathering
	case TasksRewardDataSchemaCooldownReasonBuyGe:
		*s = TasksRewardDataSchemaCooldownReasonBuyGe
	case TasksRewardDataSchemaCooldownReasonSellGe:
		*s = TasksRewardDataSchemaCooldownReasonSellGe
	case TasksRewardDataSchemaCooldownReasonCancelGe:
		*s = TasksRewardDataSchemaCooldownReasonCancelGe
	case TasksRewardDataSchemaCooldownReasonDeleteItem:
		*s = TasksRewardDataSchemaCooldownReasonDeleteItem
	case TasksRewardDataSchemaCooldownReasonDeposit:
		*s = TasksRewardDataSchemaCooldownReasonDeposit
	case TasksRewardDataSchemaCooldownReasonWithdraw:
		*s = TasksRewardDataSchemaCooldownReasonWithdraw
	case TasksRewardDataSchemaCooldownReasonDepositGold:
		*s = TasksRewardDataSchemaCooldownReasonDepositGold
	case TasksRewardDataSchemaCooldownReasonWithdrawGold:
		*s = TasksRewardDataSchemaCooldownReasonWithdrawGold
	case TasksRewardDataSchemaCooldownReasonEquip:
		*s = TasksRewardDataSchemaCooldownReasonEquip
	case TasksRewardDataSchemaCooldownReasonUnequip:
		*s = TasksRewardDataSchemaCooldownReasonUnequip
	case TasksRewardDataSchemaCooldownReasonTask:
		*s = TasksRewardDataSchemaCooldownReasonTask
	case TasksRewardDataSchemaCooldownReasonRecycling:
		*s = TasksRewardDataSchemaCooldownReasonRecycling
	case TasksRewardDataSchemaCooldownReasonRest:
		*s = TasksRewardDataSchemaCooldownReasonRest
	case TasksRewardDataSchemaCooldownReasonUse:
		*s = TasksRewardDataSchemaCooldownReasonUse
	case TasksRewardDataSchemaCooldownReasonBuyBankExpansion:
		*s = TasksRewardDataSchemaCooldownReasonBuyBankExpansion
	default:
		*s = TasksRewardDataSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TasksRewardDataSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardDataSchemaRewards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardDataSchemaRewards) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
}

var jsonFieldsNameOfTasksRewardDataSchemaRewards = [2]string{
	0: "items",
	1: "gold",
}

// Decode decodes TasksRewardDataSchemaRewards from json.
func (s *TasksRewardDataSchemaRewards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardDataSchemaRewards to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]SimpleItemSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleItemSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardDataSchemaRewards")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardDataSchemaRewards) {
					name = jsonFieldsNameOfTasksRewardDataSchemaRewards[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardDataSchemaRewards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardDataSchemaRewards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TasksRewardResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TasksRewardResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTasksRewardResponseSchema = [1]string{
	0: "data",
}

// Decode decodes TasksRewardResponseSchema from json.
func (s *TasksRewardResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TasksRewardResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TasksRewardResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTasksRewardResponseSchema) {
					name = jsonFieldsNameOfTasksRewardResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TasksRewardResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TasksRewardResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfTokenResponseSchema = [1]string{
	0: "token",
}

// Decode decodes TokenResponseSchema from json.
func (s *TokenResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenResponseSchema) {
					name = jsonFieldsNameOfTokenResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnequipSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnequipSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slot")
		s.Slot.Encode(e)
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnequipSchema = [2]string{
	0: "slot",
	1: "quantity",
}

// Decode decodes UnequipSchema from json.
func (s *UnequipSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnequipSchema to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slot":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Slot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slot\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnequipSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnequipSchema) {
					name = jsonFieldsNameOfUnequipSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnequipSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnequipSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnequipSchemaSlot as json.
func (s UnequipSchemaSlot) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UnequipSchemaSlot from json.
func (s *UnequipSchemaSlot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnequipSchemaSlot to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UnequipSchemaSlot(v) {
	case UnequipSchemaSlotWeapon:
		*s = UnequipSchemaSlotWeapon
	case UnequipSchemaSlotShield:
		*s = UnequipSchemaSlotShield
	case UnequipSchemaSlotHelmet:
		*s = UnequipSchemaSlotHelmet
	case UnequipSchemaSlotBodyArmor:
		*s = UnequipSchemaSlotBodyArmor
	case UnequipSchemaSlotLegArmor:
		*s = UnequipSchemaSlotLegArmor
	case UnequipSchemaSlotBoots:
		*s = UnequipSchemaSlotBoots
	case UnequipSchemaSlotRing1:
		*s = UnequipSchemaSlotRing1
	case UnequipSchemaSlotRing2:
		*s = UnequipSchemaSlotRing2
	case UnequipSchemaSlotAmulet:
		*s = UnequipSchemaSlotAmulet
	case UnequipSchemaSlotArtifact1:
		*s = UnequipSchemaSlotArtifact1
	case UnequipSchemaSlotArtifact2:
		*s = UnequipSchemaSlotArtifact2
	case UnequipSchemaSlotArtifact3:
		*s = UnequipSchemaSlotArtifact3
	case UnequipSchemaSlotUtility1:
		*s = UnequipSchemaSlotUtility1
	case UnequipSchemaSlotUtility2:
		*s = UnequipSchemaSlotUtility2
	default:
		*s = UnequipSchemaSlot(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnequipSchemaSlot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnequipSchemaSlot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UseItemResponseSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UseItemResponseSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUseItemResponseSchema = [1]string{
	0: "data",
}

// Decode decodes UseItemResponseSchema from json.
func (s *UseItemResponseSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UseItemResponseSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UseItemResponseSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUseItemResponseSchema) {
					name = jsonFieldsNameOfUseItemResponseSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UseItemResponseSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UseItemResponseSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UseItemSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UseItemSchema) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cooldown")
		s.Cooldown.Encode(e)
	}
	{
		e.FieldStart("item")
		s.Item.Encode(e)
	}
	{
		e.FieldStart("character")
		s.Character.Encode(e)
	}
}

var jsonFieldsNameOfUseItemSchema = [3]string{
	0: "cooldown",
	1: "item",
	2: "character",
}

// Decode decodes UseItemSchema from json.
func (s *UseItemSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UseItemSchema to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cooldown":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Cooldown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "item":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Item.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item\"")
			}
		case "character":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Character.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UseItemSchema")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUseItemSchema) {
					name = jsonFieldsNameOfUseItemSchema[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UseItemSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UseItemSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UseItemSchemaCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UseItemSchemaCharacter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account")
		e.Str(s.Account)
	}
	{
		e.FieldStart("skin")
		s.Skin.Encode(e)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("xp")
		e.Int(s.Xp)
	}
	{
		e.FieldStart("max_xp")
		e.Int(s.MaxXp)
	}
	{
		e.FieldStart("gold")
		e.Int(s.Gold)
	}
	{
		e.FieldStart("speed")
		e.Int(s.Speed)
	}
	{
		e.FieldStart("mining_level")
		e.Int(s.MiningLevel)
	}
	{
		e.FieldStart("mining_xp")
		e.Int(s.MiningXp)
	}
	{
		e.FieldStart("mining_max_xp")
		e.Int(s.MiningMaxXp)
	}
	{
		e.FieldStart("woodcutting_level")
		e.Int(s.WoodcuttingLevel)
	}
	{
		e.FieldStart("woodcutting_xp")
		e.Int(s.WoodcuttingXp)
	}
	{
		e.FieldStart("woodcutting_max_xp")
		e.Int(s.WoodcuttingMaxXp)
	}
	{
		e.FieldStart("fishing_level")
		e.Int(s.FishingLevel)
	}
	{
		e.FieldStart("fishing_xp")
		e.Int(s.FishingXp)
	}
	{
		e.FieldStart("fishing_max_xp")
		e.Int(s.FishingMaxXp)
	}
	{
		e.FieldStart("weaponcrafting_level")
		e.Int(s.WeaponcraftingLevel)
	}
	{
		e.FieldStart("weaponcrafting_xp")
		e.Int(s.WeaponcraftingXp)
	}
	{
		e.FieldStart("weaponcrafting_max_xp")
		e.Int(s.WeaponcraftingMaxXp)
	}
	{
		e.FieldStart("gearcrafting_level")
		e.Int(s.GearcraftingLevel)
	}
	{
		e.FieldStart("gearcrafting_xp")
		e.Int(s.GearcraftingXp)
	}
	{
		e.FieldStart("gearcrafting_max_xp")
		e.Int(s.GearcraftingMaxXp)
	}
	{
		e.FieldStart("jewelrycrafting_level")
		e.Int(s.JewelrycraftingLevel)
	}
	{
		e.FieldStart("jewelrycrafting_xp")
		e.Int(s.JewelrycraftingXp)
	}
	{
		e.FieldStart("jewelrycrafting_max_xp")
		e.Int(s.JewelrycraftingMaxXp)
	}
	{
		e.FieldStart("cooking_level")
		e.Int(s.CookingLevel)
	}
	{
		e.FieldStart("cooking_xp")
		e.Int(s.CookingXp)
	}
	{
		e.FieldStart("cooking_max_xp")
		e.Int(s.CookingMaxXp)
	}
	{
		e.FieldStart("alchemy_level")
		e.Int(s.AlchemyLevel)
	}
	{
		e.FieldStart("alchemy_xp")
		e.Int(s.AlchemyXp)
	}
	{
		e.FieldStart("alchemy_max_xp")
		e.Int(s.AlchemyMaxXp)
	}
	{
		e.FieldStart("hp")
		e.Int(s.Hp)
	}
	{
		e.FieldStart("max_hp")
		e.Int(s.MaxHp)
	}
	{
		e.FieldStart("haste")
		e.Int(s.Haste)
	}
	{
		e.FieldStart("critical_strike")
		e.Int(s.CriticalStrike)
	}
	{
		e.FieldStart("stamina")
		e.Int(s.Stamina)
	}
	{
		e.FieldStart("attack_fire")
		e.Int(s.AttackFire)
	}
	{
		e.FieldStart("attack_earth")
		e.Int(s.AttackEarth)
	}
	{
		e.FieldStart("attack_water")
		e.Int(s.AttackWater)
	}
	{
		e.FieldStart("attack_air")
		e.Int(s.AttackAir)
	}
	{
		e.FieldStart("dmg_fire")
		e.Int(s.DmgFire)
	}
	{
		e.FieldStart("dmg_earth")
		e.Int(s.DmgEarth)
	}
	{
		e.FieldStart("dmg_water")
		e.Int(s.DmgWater)
	}
	{
		e.FieldStart("dmg_air")
		e.Int(s.DmgAir)
	}
	{
		e.FieldStart("res_fire")
		e.Int(s.ResFire)
	}
	{
		e.FieldStart("res_earth")
		e.Int(s.ResEarth)
	}
	{
		e.FieldStart("res_water")
		e.Int(s.ResWater)
	}
	{
		e.FieldStart("res_air")
		e.Int(s.ResAir)
	}
	{
		e.FieldStart("x")
		e.Int(s.X)
	}
	{
		e.FieldStart("y")
		e.Int(s.Y)
	}
	{
		e.FieldStart("cooldown")
		e.Int(s.Cooldown)
	}
	{
		if s.CooldownExpiration.Set {
			e.FieldStart("cooldown_expiration")
			s.CooldownExpiration.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("weapon_slot")
		e.Str(s.WeaponSlot)
	}
	{
		e.FieldStart("shield_slot")
		e.Str(s.ShieldSlot)
	}
	{
		e.FieldStart("helmet_slot")
		e.Str(s.HelmetSlot)
	}
	{
		e.FieldStart("body_armor_slot")
		e.Str(s.BodyArmorSlot)
	}
	{
		e.FieldStart("leg_armor_slot")
		e.Str(s.LegArmorSlot)
	}
	{
		e.FieldStart("boots_slot")
		e.Str(s.BootsSlot)
	}
	{
		e.FieldStart("ring1_slot")
		e.Str(s.Ring1Slot)
	}
	{
		e.FieldStart("ring2_slot")
		e.Str(s.Ring2Slot)
	}
	{
		e.FieldStart("amulet_slot")
		e.Str(s.AmuletSlot)
	}
	{
		e.FieldStart("artifact1_slot")
		e.Str(s.Artifact1Slot)
	}
	{
		e.FieldStart("artifact2_slot")
		e.Str(s.Artifact2Slot)
	}
	{
		e.FieldStart("artifact3_slot")
		e.Str(s.Artifact3Slot)
	}
	{
		e.FieldStart("utility1_slot")
		e.Str(s.Utility1Slot)
	}
	{
		e.FieldStart("utility1_slot_quantity")
		e.Int(s.Utility1SlotQuantity)
	}
	{
		e.FieldStart("utility2_slot")
		e.Str(s.Utility2Slot)
	}
	{
		e.FieldStart("utility2_slot_quantity")
		e.Int(s.Utility2SlotQuantity)
	}
	{
		e.FieldStart("task")
		e.Str(s.Task)
	}
	{
		e.FieldStart("task_type")
		e.Str(s.TaskType)
	}
	{
		e.FieldStart("task_progress")
		e.Int(s.TaskProgress)
	}
	{
		e.FieldStart("task_total")
		e.Int(s.TaskTotal)
	}
	{
		e.FieldStart("inventory_max_items")
		e.Int(s.InventoryMaxItems)
	}
	{
		if s.Inventory != nil {
			e.FieldStart("inventory")
			e.ArrStart()
			for _, elem := range s.Inventory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUseItemSchemaCharacter = [75]string{
	0:  "name",
	1:  "account",
	2:  "skin",
	3:  "level",
	4:  "xp",
	5:  "max_xp",
	6:  "gold",
	7:  "speed",
	8:  "mining_level",
	9:  "mining_xp",
	10: "mining_max_xp",
	11: "woodcutting_level",
	12: "woodcutting_xp",
	13: "woodcutting_max_xp",
	14: "fishing_level",
	15: "fishing_xp",
	16: "fishing_max_xp",
	17: "weaponcrafting_level",
	18: "weaponcrafting_xp",
	19: "weaponcrafting_max_xp",
	20: "gearcrafting_level",
	21: "gearcrafting_xp",
	22: "gearcrafting_max_xp",
	23: "jewelrycrafting_level",
	24: "jewelrycrafting_xp",
	25: "jewelrycrafting_max_xp",
	26: "cooking_level",
	27: "cooking_xp",
	28: "cooking_max_xp",
	29: "alchemy_level",
	30: "alchemy_xp",
	31: "alchemy_max_xp",
	32: "hp",
	33: "max_hp",
	34: "haste",
	35: "critical_strike",
	36: "stamina",
	37: "attack_fire",
	38: "attack_earth",
	39: "attack_water",
	40: "attack_air",
	41: "dmg_fire",
	42: "dmg_earth",
	43: "dmg_water",
	44: "dmg_air",
	45: "res_fire",
	46: "res_earth",
	47: "res_water",
	48: "res_air",
	49: "x",
	50: "y",
	51: "cooldown",
	52: "cooldown_expiration",
	53: "weapon_slot",
	54: "shield_slot",
	55: "helmet_slot",
	56: "body_armor_slot",
	57: "leg_armor_slot",
	58: "boots_slot",
	59: "ring1_slot",
	60: "ring2_slot",
	61: "amulet_slot",
	62: "artifact1_slot",
	63: "artifact2_slot",
	64: "artifact3_slot",
	65: "utility1_slot",
	66: "utility1_slot_quantity",
	67: "utility2_slot",
	68: "utility2_slot_quantity",
	69: "task",
	70: "task_type",
	71: "task_progress",
	72: "task_total",
	73: "inventory_max_items",
	74: "inventory",
}

// Decode decodes UseItemSchemaCharacter from json.
func (s *UseItemSchemaCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UseItemSchemaCharacter to nil")
	}
	var requiredBitSet [10]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Account = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "skin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Skin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "xp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Xp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		case "max_xp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_xp\"")
			}
		case "gold":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Gold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold\"")
			}
		case "speed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Speed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "mining_level":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MiningLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_level\"")
			}
		case "mining_xp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MiningXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_xp\"")
			}
		case "mining_max_xp":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MiningMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mining_max_xp\"")
			}
		case "woodcutting_level":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_level\"")
			}
		case "woodcutting_xp":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_xp\"")
			}
		case "woodcutting_max_xp":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WoodcuttingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"woodcutting_max_xp\"")
			}
		case "fishing_level":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.FishingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_level\"")
			}
		case "fishing_xp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.FishingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_xp\"")
			}
		case "fishing_max_xp":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FishingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fishing_max_xp\"")
			}
		case "weaponcrafting_level":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_level\"")
			}
		case "weaponcrafting_xp":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_xp\"")
			}
		case "weaponcrafting_max_xp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WeaponcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weaponcrafting_max_xp\"")
			}
		case "gearcrafting_level":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_level\"")
			}
		case "gearcrafting_xp":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_xp\"")
			}
		case "gearcrafting_max_xp":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.GearcraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gearcrafting_max_xp\"")
			}
		case "jewelrycrafting_level":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_level\"")
			}
		case "jewelrycrafting_xp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_xp\"")
			}
		case "jewelrycrafting_max_xp":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.JewelrycraftingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jewelrycrafting_max_xp\"")
			}
		case "cooking_level":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CookingLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_level\"")
			}
		case "cooking_xp":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CookingXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_xp\"")
			}
		case "cooking_max_xp":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CookingMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooking_max_xp\"")
			}
		case "alchemy_level":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AlchemyLevel = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_level\"")
			}
		case "alchemy_xp":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AlchemyXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_xp\"")
			}
		case "alchemy_max_xp":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AlchemyMaxXp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alchemy_max_xp\"")
			}
		case "hp":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Hp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "max_hp":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxHp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_hp\"")
			}
		case "haste":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Haste = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"haste\"")
			}
		case "critical_strike":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CriticalStrike = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"critical_strike\"")
			}
		case "stamina":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Stamina = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stamina\"")
			}
		case "attack_fire":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.AttackFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_fire\"")
			}
		case "attack_earth":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.AttackEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_earth\"")
			}
		case "attack_water":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.AttackWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_water\"")
			}
		case "attack_air":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AttackAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attack_air\"")
			}
		case "dmg_fire":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DmgFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_fire\"")
			}
		case "dmg_earth":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DmgEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_earth\"")
			}
		case "dmg_water":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DmgWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_water\"")
			}
		case "dmg_air":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DmgAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dmg_air\"")
			}
		case "res_fire":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ResFire = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_fire\"")
			}
		case "res_earth":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ResEarth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_earth\"")
			}
		case "res_water":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResWater = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_water\"")
			}
		case "res_air":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ResAir = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"res_air\"")
			}
		case "x":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.X = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		case "cooldown":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Cooldown = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown\"")
			}
		case "cooldown_expiration":
			if err := func() error {
				s.CooldownExpiration.Reset()
				if err := s.CooldownExpiration.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldown_expiration\"")
			}
		case "weapon_slot":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WeaponSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon_slot\"")
			}
		case "shield_slot":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ShieldSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shield_slot\"")
			}
		case "helmet_slot":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HelmetSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmet_slot\"")
			}
		case "body_armor_slot":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BodyArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_armor_slot\"")
			}
		case "leg_armor_slot":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LegArmorSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leg_armor_slot\"")
			}
		case "boots_slot":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BootsSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boots_slot\"")
			}
		case "ring1_slot":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Ring1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring1_slot\"")
			}
		case "ring2_slot":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ring2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ring2_slot\"")
			}
		case "amulet_slot":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AmuletSlot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amulet_slot\"")
			}
		case "artifact1_slot":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Artifact1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact1_slot\"")
			}
		case "artifact2_slot":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Artifact2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact2_slot\"")
			}
		case "artifact3_slot":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Artifact3Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifact3_slot\"")
			}
		case "utility1_slot":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Utility1Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot\"")
			}
		case "utility1_slot_quantity":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Utility1SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility1_slot_quantity\"")
			}
		case "utility2_slot":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Utility2Slot = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot\"")
			}
		case "utility2_slot_quantity":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Utility2SlotQuantity = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utility2_slot_quantity\"")
			}
		case "task":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "task_type":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TaskType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_type\"")
			}
		case "task_progress":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TaskProgress = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_progress\"")
			}
		case "task_total":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TaskTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task_total\"")
			}
		case "inventory_max_items":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.InventoryMaxItems = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory_max_items\"")
			}
		case "inventory":
			if err := func() error {
				s.Inventory = make([]InventorySlot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InventorySlot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inventory = append(s.Inventory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inventory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UseItemSchemaCharacter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [10]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUseItemSchemaCharacter) {
					name = jsonFieldsNameOfUseItemSchemaCharacter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UseItemSchemaCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UseItemSchemaCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UseItemSchemaCharacterSkin as json.
func (s UseItemSchemaCharacterSkin) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UseItemSchemaCharacterSkin from json.
func (s *UseItemSchemaCharacterSkin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UseItemSchemaCharacterSkin to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UseItemSchemaCharacterSkin(v) {
	case UseItemSchemaCharacterSkinMen1:
		*s = UseItemSchemaCharacterSkinMen1
	case UseItemSchemaCharacterSkinMen2:
		*s = UseItemSchemaCharacterSkinMen2
	case UseItemSchemaCharacterSkinMen3:
		*s = UseItemSchemaCharacterSkinMen3
	case UseItemSchemaCharacterSkinWomen1:
		*s = UseItemSchemaCharacterSkinWomen1
	case UseItemSchemaCharacterSkinWomen2:
		*s = UseItemSchemaCharacterSkinWomen2
	case UseItemSchemaCharacterSkinWomen3:
		*s = UseItemSchemaCharacterSkinWomen3
	default:
		*s = UseItemSchemaCharacterSkin(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UseItemSchemaCharacterSkin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UseItemSchemaCharacterSkin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UseItemSchemaCooldown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UseItemSchemaCooldown) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_seconds")
		e.Int(s.TotalSeconds)
	}
	{
		e.FieldStart("remaining_seconds")
		e.Int(s.RemainingSeconds)
	}
	{
		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.FieldStart("expiration")
		json.EncodeDateTime(e, s.Expiration)
	}
	{
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
}

var jsonFieldsNameOfUseItemSchemaCooldown = [5]string{
	0: "total_seconds",
	1: "remaining_seconds",
	2: "started_at",
	3: "expiration",
	4: "reason",
}

// Decode decodes UseItemSchemaCooldown from json.
func (s *UseItemSchemaCooldown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UseItemSchemaCooldown to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_seconds\"")
			}
		case "remaining_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RemainingSeconds = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining_seconds\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "expiration":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Expiration = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UseItemSchemaCooldown")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUseItemSchemaCooldown) {
					name = jsonFieldsNameOfUseItemSchemaCooldown[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UseItemSchemaCooldown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UseItemSchemaCooldown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UseItemSchemaCooldownReason as json.
func (s UseItemSchemaCooldownReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UseItemSchemaCooldownReason from json.
func (s *UseItemSchemaCooldownReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UseItemSchemaCooldownReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UseItemSchemaCooldownReason(v) {
	case UseItemSchemaCooldownReasonMovement:
		*s = UseItemSchemaCooldownReasonMovement
	case UseItemSchemaCooldownReasonFight:
		*s = UseItemSchemaCooldownReasonFight
	case UseItemSchemaCooldownReasonCrafting:
		*s = UseItemSchemaCooldownReasonCrafting
	case UseItemSchemaCooldownReasonGathering:
		*s = UseItemSchemaCooldownReasonGathering
	case UseItemSchemaCooldownReasonBuyGe:
		*s = UseItemSchemaCooldownReasonBuyGe
	case UseItemSchemaCooldownReasonSellGe:
		*s = UseItemSchemaCooldownReasonSellGe
	case UseItemSchemaCooldownReasonCancelGe:
		*s = UseItemSchemaCooldownReasonCancelGe
	case UseItemSchemaCooldownReasonDeleteItem:
		*s = UseItemSchemaCooldownReasonDeleteItem
	case UseItemSchemaCooldownReasonDeposit:
		*s = UseItemSchemaCooldownReasonDeposit
	case UseItemSchemaCooldownReasonWithdraw:
		*s = UseItemSchemaCooldownReasonWithdraw
	case UseItemSchemaCooldownReasonDepositGold:
		*s = UseItemSchemaCooldownReasonDepositGold
	case UseItemSchemaCooldownReasonWithdrawGold:
		*s = UseItemSchemaCooldownReasonWithdrawGold
	case UseItemSchemaCooldownReasonEquip:
		*s = UseItemSchemaCooldownReasonEquip
	case UseItemSchemaCooldownReasonUnequip:
		*s = UseItemSchemaCooldownReasonUnequip
	case UseItemSchemaCooldownReasonTask:
		*s = UseItemSchemaCooldownReasonTask
	case UseItemSchemaCooldownReasonRecycling:
		*s = UseItemSchemaCooldownReasonRecycling
	case UseItemSchemaCooldownReasonRest:
		*s = UseItemSchemaCooldownReasonRest
	case UseItemSchemaCooldownReasonUse:
		*s = UseItemSchemaCooldownReasonUse
	case UseItemSchemaCooldownReasonBuyBankExpansion:
		*s = UseItemSchemaCooldownReasonBuyBankExpansion
	default:
		*s = UseItemSchemaCooldownReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UseItemSchemaCooldownReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UseItemSchemaCooldownReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UseItemSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UseItemSchemaItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("level")
		e.Int(s.Level)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("subtype")
		e.Str(s.Subtype)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Effects != nil {
			e.FieldStart("effects")
			e.ArrStart()
			for _, elem := range s.Effects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Craft.Set {
			e.FieldStart("craft")
			s.Craft.Encode(e)
		}
	}
	{
		e.FieldStart("tradeable")
		e.Bool(s.Tradeable)
	}
}

var jsonFieldsNameOfUseItemSchemaItem = [9]string{
	0: "name",
	1: "code",
	2: "level",
	3: "type",
	4: "subtype",
	5: "description",
	6: "effects",
	7: "craft",
	8: "tradeable",
}

// Decode decodes UseItemSchemaItem from json.
func (s *UseItemSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UseItemSchemaItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Level = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "subtype":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Subtype = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtype\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "effects":
			if err := func() error {
				s.Effects = make([]ItemEffectSchema, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ItemEffectSchema
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Effects = append(s.Effects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effects\"")
			}
		case "craft":
			if err := func() error {
				s.Craft.Reset()
				if err := s.Craft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"craft\"")
			}
		case "tradeable":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Tradeable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UseItemSchemaItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUseItemSchemaItem) {
					name = jsonFieldsNameOfUseItemSchemaItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UseItemSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UseItemSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UseItemSchemaItemCraft as json.
func (s UseItemSchemaItemCraft) Encode(e *jx.Encoder) {
	switch s.Type {
	case CraftSchemaUseItemSchemaItemCraft:
		s.CraftSchema.Encode(e)
	case NullUseItemSchemaItemCraft:
		_ = s.Null
		e.Null()
	}
}

// Decode decodes UseItemSchemaItemCraft from json.
func (s *UseItemSchemaItemCraft) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UseItemSchemaItemCraft to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		s.Type = NullUseItemSchemaItemCraft
	case jx.Object:
		if err := s.CraftSchema.Decode(d); err != nil {
			return err
		}
		s.Type = CraftSchemaUseItemSchemaItemCraft
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UseItemSchemaItemCraft) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UseItemSchemaItemCraft) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
